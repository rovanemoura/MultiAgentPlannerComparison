(in-package "COMMON-LISP-USER")

;; in case I do not use it with ERRT
(defvar *trace-errt-p* nil)
(defvar *domain-name* nil)
(defvar *ehc-solution* nil "To store the EHC search when expanding afterwards to A*")
;; (defvar *a-star-solution* nil "To store the A* search when expanding after EHC")

;; For drive-based planning
(defvar *max-drive* 3 "Maximum value of a drive to be considered normal")
;; These names have to do with negated functions in Sayphi
(defvar *drives* (list '_hunger '_thirst '_boredom '_tiredness '_dirtiness) "List of drives")
(defvar *drives-actions* '((_hunger eat) (_thirst drink) (_boredom play) (_sleepiness sleep) (_dirtiness bath)))
;; (defvar *drives* (list 'hunger 'thirst 'boredom 'tiredness 'dirtiness) "List of drives")
;; (defvar *drives-actions* '((hunger eat) (thirst drink) (boredom play) (sleepiness sleep) (dirtiness bath)))
(defvar *last-node* nil "So that we can inspect it at the end")


(defun say-domain (domain-dir &optional (domain-file "domain.pddl") (change-dirs-p t))
  ;; somtimes I do not want Sayphi to change paths. For instance, when the structure of paths is not the one from Sayphi, but rather the one from the IPC
  (when change-dirs-p
    (setf *domain-dir* (concatenate 'string *domains-dir* domain-dir "/"))
    (setf *results-pathname* (concatenate 'string *domain-dir* "result/"))
    (ensure-directories-exist *results-pathname*)
    (ensure-directories-exist (concatenate 'string *results-pathname* "internal/"))
    ;; for compatility with IPSS
    (setf *domain-name* domain-dir))
  (setf *domain-file* (concatenate 'string *domain-dir* domain-file))
  (read-pddl-domain *domain-file*)
  (if (> *say-output* 0)
      (format t "~% ~a domain loaded!" domain-dir))
  t)

(defun prob (problem-file &optional (use-sayphi-vars-p t))
  (cond ((null *domain-dir*)
	 (error (msg-error 'no_domain_dir 'problem)))
	(t
	 (read-pddl-problem (if use-sayphi-vars-p
				(concatenate 'string *domain-dir* *problem-dir* problem-file)
				problem-file))
	 (setf *problem-file* problem-file)
	 (setf *complete-problem-file* problem-file)
	 (if (> *say-output* 0)
	     (format t "~% ~a problem loaded!" problem-file))
	 t)))

(defun enforced-hill-climbing (init-node h-fn cost-fn search-options &optional (problem *current-problem*))
  (declare (ignore cost-fn))
  (let ((open-nodes nil) (open-children nil)
	(node init-node) (next-node nil) (visited (make-hash-table))
	(current-h 0) (current-h-plus 0) (better-h-node nil) (discrete-h (not (is-metric-domain)))
	(lookahead (search-option-value :lookahead search-options))
	(helpful (search-option-value :helpful search-options)))

    (cond (*trace-mem* 
	   (say-consed-bytes :mem-per-node (store-h-extras node h-fn))
	   (write-node-mem-info 'ehc))
	  (t (store-h-extras node h-fn)))

    (setf current-h (snode-h-value node))
    (setf current-h-plus (snode-h-plus node))
    (do* ((stop-this (stop-search node problem) (stop-search node problem)))
	 (stop-this (when-stop (cdr stop-this) node problem))
      
      ;;(trace-search-extras (snode-number node))
      (expand-state node :helpful helpful)
      (when lookahead (expand-node-lookahead node lookahead visited))

      (print-search-node node nil)

      (setf better-h-node (get-enforced-heuristic node h-fn current-h visited :discrete discrete-h 
						  :current-h-plus current-h-plus))
      (cond ((snode-p better-h-node)
	     (setf current-h (snode-h-value better-h-node))
	     (setf current-h-plus (snode-h-plus better-h-node))
	     (setf node better-h-node)
	     (setf open-nodes nil)
	     (setf open-children nil)
 	     (setf visited (reset-hash-visited node))
	     )
	    (t 
	     (setf open-children (nconc (remove-if #'snode-closed (snode-children node)) 
				       open-children))
	     
	     (cond ((not (snode-p (setf next-node (pop open-nodes))))
		    (when (> *say-output* 1) (format t "  ~% [Expanding Breadth Level]"))
		    (setf open-nodes (ehc-open-nodes open-children (car (find-argument search-options :children-sort))))
		    
		    (when (null open-nodes) ;;Recuperando la poda por las helpful actions
		      (dolist (i-child (restore-nonhelpful node h-fn))
			(cond ((find i-child (gethash (snode-hash-code i-child) visited) :test #'equal-state)
			       (setf (snode-closed i-child) t))
			      (t 
			       (push i-child (gethash (snode-hash-code i-child) visited))
			       (push i-child open-nodes))))
			       
;; 		      (setf open-nodes (restore-nonhelpful node h-fn))
		      
		      (when (> *say-output* 1) 
			(format t "  ~%!!Restoring NON Helpful Nodes.")))
		    (setf node (pop open-nodes))
		    (setf open-children nil))
		   (t 
		    (setf node next-node)))))       
      ;; 	 (when (snode-p node)
      ;; 	   (print-search-node node nil)
      )))

(defun learning-enforced-hill-climbing (init-node h-fn cost-fn search-options &optional (problem *current-problem*))
  (declare (ignore cost-fn))
  (let ((open-nodes nil) (open-children nil)
	(node init-node) (next-node nil) (visited (make-hash-table))
	(current-h 0) (current-h-plus 0) (better-h-node nil) (discrete-h (not (is-metric-domain)))
	(lookahead (search-option-value :lookahead search-options))
	(helpful (search-option-value :helpful search-options))
	(use-rules-p (car (find-argument search-options :use-rules-p))))

    (cond (*trace-mem* 
	   (say-consed-bytes :mem-per-node (store-h-extras node h-fn))
	   (write-node-mem-info 'ehc))
	  (t (store-h-extras node h-fn)))

    (setf current-h (snode-h-value node))
    (setf current-h-plus (snode-h-plus node))
    (when (and use-rules-p *rete-root-node*)
	(push-to-rete-goals)
	(push-to-rete-object-types)
      (push-to-rete-state init-node t))
;;       (push-to-rete-state nil previous-state))
;;     (setf open-nodes (list node))
    (do* ((stop-this (stop-search node problem) (stop-search node problem)))
	 (stop-this (when-stop (cdr stop-this) node problem))
      
      (trace-search-extras (snode-number node))
      (expand-state node :helpful helpful)
      (when lookahead (expand-node-lookahead node lookahead visited))

      (print-search-node node nil)
      
;;      (push node (gethash (snode-hash-code node) visited))	     
;;       (when *generate-learning-examples-p* (save-examples node better-h-node nil))
      (if use-rules-p
	  (prune-by-rules node))
      (setf better-h-node (get-enforced-heuristic node h-fn current-h visited :discrete discrete-h :current-h-plus current-h-plus))
      (cond ((snode-p better-h-node)
	     (setf current-h (snode-h-value better-h-node))
	     (setf current-h-plus (snode-h-plus better-h-node))
	     (setf node better-h-node)
	     (setf open-nodes nil)
	     (setf open-children nil)
 	     (setf visited (reset-hash-visited node)))
	    (t (setf open-children (nconc (remove-if #'snode-closed (snode-children node)) 
					  open-children))
	     (cond ((not (snode-p (setf next-node (pop open-nodes))))
		    (when *trace-errt-p* (format t "  ~% [Expanding Breadth Level]"))
		    (setf open-nodes (ehc-open-nodes open-children (car (find-argument search-options :children-sort))))
		    (when (null open-nodes) ;;Recuperando la poda por las helpful actions
		      (setf open-nodes (restore-nonhelpful node h-fn))
		      (when *trace-errt-p* (format t "  ~%!!Restoring NON Helpful Nodes.")))
		    (setf node (pop open-nodes))
		    (setf open-children nil))
		   (t 
		    (setf node next-node)))))
      ;; Now it is efficient
    (if (and *rete-root-node* (car (find-argument search-options :use-rules-p)))
	(push-to-rete-state node nil))
;; 	(push-to-rete-state previous-state (setq previous-state (pp-state (snode-state node) 'list))))
      ;; 	 (when (snode-p node)
      ;; 	   (print-search-node node nil)
      )))

;; requires the use of use-rules-p=t, p=probability of using learned knowledge and deterministicp=t means making deterministic choices on selecting actions and bindings
(defun ehc-tilde (init-node h-fn cost-fn search-options &optional (problem *current-problem*))
  (declare (ignore cost-fn))
  (let ((open-nodes nil) (open-children nil)
	(node init-node) (next-node nil) (visited (make-hash-table))
	(current-h 0) (current-h-plus 0) (better-h-node nil) (discrete-h (not (is-metric-domain)))
	(lookahead (search-option-value :lookahead search-options))
	(helpful (search-option-value :helpful search-options))
	(use-rules-p (car (find-argument search-options :use-rules-p)))
	(deterministicp (car (find-argument search-options :deterministicp)))
	(p (car (find-argument search-options :p))))
    (cond (*trace-mem* 
	   (say-consed-bytes :mem-per-node (store-h-extras node h-fn))
	   (write-node-mem-info 'ehc))
	  (t (store-h-extras node h-fn)))
    (setf current-h (snode-h-value node))
    (setf current-h-plus (snode-h-plus node))
    (do* ((stop-this (stop-search node problem) (stop-search node problem)))
	 (stop-this (when-stop (cdr stop-this) node problem))
      (trace-search-extras (snode-number node))
      (expand-state node :helpful helpful)
      (when lookahead (expand-node-lookahead node lookahead visited))
      (print-search-node node nil)
      ;;      (push node (gethash (snode-hash-code node) visited))	     
      ;;       (when *generate-learning-examples-p* (save-examples node better-h-node nil))
      (if use-rules-p (prune-by-tilde-tree node p deterministicp))
      (setf better-h-node (get-enforced-heuristic node h-fn current-h visited :discrete discrete-h :current-h-plus current-h-plus))
      (cond ((snode-p better-h-node)
	     (setf current-h (snode-h-value better-h-node))
	     (setf current-h-plus (snode-h-plus better-h-node))
	     (setf node better-h-node)
	     (setf open-nodes nil)
	     (setf open-children nil)
 	     (setf visited (reset-hash-visited node)))
	    (t (setf open-children (nconc (remove-if #'snode-closed (snode-children node)) open-children))
	       (cond ((not (snode-p (setf next-node (pop open-nodes))))
		      (when *trace-errt-p* (format t "  ~% [Expanding Breadth Level]"))
		      (setf open-nodes (ehc-open-nodes open-children (car (find-argument search-options :children-sort))))
		      (when (null open-nodes) ;;Recuperando la poda por las helpful actions
			(setf open-nodes (restore-nonhelpful node h-fn))
			(when *trace-errt-p* (format t "  ~%!!Restoring NON Helpful Nodes.")))
		      (setf node (pop open-nodes))
		      (setf open-children nil))
		     (t (setf node next-node))))))))

;; requires the use of use-rules-p=t, p=probability of using learned knowledge and deterministicp=t means making deterministic choices on selecting actions and bindings
(defun hc-bnb-tilde (init-node h-function cost-fn search-options &key (problem *current-problem*))
  (when (> *say-output* 0) (format t "~% Finding EHC solution for Upper-cost Bound"))
  (let ((first-sol (clean-bnb-first-sol (ehc-tilde init-node h-function cost-fn search-options)))
	(visited (make-hash-table)) (siblings nil)
	(hash-solutions (make-hash-table))
	(node init-node) (repeated nil)
	(upper-cost-bound nil)
;; 	(not-prune-inconsistent (search-option-value :not-prune-inconsistent search-options))
	(max-solutions (search-option-value :max-solutions search-options))
	(exhaustive-search (search-option-value :exhaustive-search search-options))
	(helpful (search-option-value :helpful search-options))
	(use-rules-p (car (find-argument search-options :use-rules-p)))
	(deterministicp (car (find-argument search-options :deterministicp)))
	(p (car (find-argument search-options :p))))
;;     (setf *hash-inconsistent-h* (make-hash-table))
    (setf *say-hash-solutions* hash-solutions)
;;    (setf *mi-hash* visited)
    (cond ((and (solution-p first-sol)
		(solution-found first-sol) (> (solution-depth first-sol) 0))
	   (setf upper-cost-bound (solution-total-cost first-sol))
	   (setf (snode-closed (solution-last-node first-sol)) t)
	   (setf (gethash 1 hash-solutions) first-sol)

	   (store-a-star-extras node cost-fn)
	   (push node (gethash (snode-hash-code node) visited))

	   (when (> *say-output* 0) (format t "~% Running Branch & Bound [~a]" upper-cost-bound))
	   
	   (do* ((stop-this (stop-multiple node problem hash-solutions max-solutions) 
			    (stop-multiple node problem hash-solutions max-solutions)))
		((car stop-this) (when-multiple-stop (cdr stop-this) node problem)) 
	     (when (snode-closed node)  ;;Goals reached
	       (when (< (solution-total-cost (gethash (hash-table-count hash-solutions) hash-solutions)) upper-cost-bound)
		 (setf *say-solution* (gethash (hash-table-count hash-solutions) hash-solutions))
		 (setf upper-cost-bound (solution-total-cost *say-solution*))
		 (when (> *say-output* 0) 
		   (format t "~% => BnB >> Found new solution with Cost {~a}" (solution-total-cost *say-solution*))))
	       (setf node (snode-parent node)))

	     (unless (snode-expanded node) 
	       (expand-state node :helpful helpful)
	       (if use-rules-p (prune-by-tilde-tree node p deterministicp)))
	     (dolist (i-child (snode-children node))
	       (unless (snode-closed i-child)
		 (cond ((null (snode-h-value i-child))
			(setf repeated 
			      (unless exhaustive-search
				(find i-child (gethash (snode-hash-code i-child) visited) :test #'equal-state)))
			(cond ((or (not (snode-p repeated))
				   (and (snode-p repeated)
					(better-g-path repeated i-child cost-fn)))
			       (store-h-extras i-child h-function)
;; 			       (when (> *say-output* 1) (format t "~% Watch This!!!"))
			       (push i-child (gethash (snode-hash-code i-child) visited)))
			      (t
			       
			       (setf (snode-closed i-child) t)
;; 			       (when (> *say-output* 1) 
;; 				 (format t "~% == BnB ==>> Not evaluated repeated node ~a" (snode-number i-child)))
			       )))
		       (t
			(when (and (not (snode-closed i-child))
				   (not (find i-child (gethash (snode-hash-code i-child) visited) :key #'snode-number)))
			  (push i-child (gethash (snode-hash-code i-child) visited)))))
		 (when (and (not (snode-closed i-child)) (null (snode-f-value i-child)))
		   (store-a-star-extras i-child cost-fn))
		 ))
	     
;; 	     (compute-inconsistent-h-nodes node)
	     
	     (setf siblings (stable-sort (remove-if #'(lambda (i-sibling)
							(or (snode-closed i-sibling)
							    (> (snode-f-value i-sibling) upper-cost-bound)
;; 								 (or (not not-prune-inconsistent)
;; 								     (and not-prune-inconsistent
;; 									  (<= (- (snode-h-value i-sibling) (snode-h-value node))
;; 									      (snode-cost i-sibling))))
								 ))
						    (snode-children node)) 
					 #'< :key #'snode-f-value))
;; ;;======================================================================
;; 	     (format t "~%~% ===>children:")
;; 	     (map nil #'(lambda (x) (format t " ~a (~a, ~a), " (snode-number x) (snode-f-value x)
;; 					    (snode-closed x))) (snode-children node)) 
;; 	     (format t "~% ===>siblings:")
;; 	     (map nil #'(lambda (x) (format t " ~a " (snode-number x))) siblings) 
;; ;;======================================================================
	     (cond ((snode-p (car siblings))
		    (setf (snode-selected (snode-parent (car siblings))) (car siblings))
		    (setf node (car siblings)))
		   (t 
		    (setf (snode-selected node) nil)
		    (setf (snode-closed node) t)
		    (when (> *say-output* 1) (format t "~% == BnB ==>> Cost Pruning at node ~a [~a]" 
						     (snode-number node) (snode-f-value node)))
		    (setf node (if (snode-p (snode-parent node)) (snode-parent node) nil))
		    
		    ))
	     
	     (when (snode-p node)
	       (print-search-node node nil))
	     ))
	  ;; 	  In case of no solution was found
	  (t first-sol))))

;; This is more or less the same as Tomas bfs-bnb
;; Hill-climbing Branch & Bound It searches first for a solution with EHC. If it does not find it, it calls A*.
;; Then, it tries to improve the solution searching with a
;; backtracking Hill-climbing pruned by the first solution upper-cost
;; bound
(defun hc-astar-bnb (init-node h-function cost-fn search-options &key (w_h 3) (problem *current-problem*))
  (when (> *say-output* 0) (format t "~% Finding EHC solution for Upper-cost Bound"))
  (let ((first-sol (clean-bnb-first-sol (enforced-hill-climbing init-node h-function cost-fn search-options)))
	(visited (make-hash-table)) (siblings nil)
	(hash-solutions (make-hash-table))
	(node init-node) (repeated nil)
	(upper-cost-bound nil)
;; 	(not-prune-inconsistent (search-option-value :not-prune-inconsistent search-options))
	(max-solutions (search-option-value :max-solutions search-options))
	(exhaustive-search (search-option-value :exhaustive-search search-options))
	(helpful (search-option-value :helpful search-options)))
;;     (setf *hash-inconsistent-h* (make-hash-table))
    (setf *say-hash-solutions* hash-solutions)
;;    (setf *mi-hash* visited)
    (if (or (not (solution-p first-sol))
	    (not (solution-found first-sol)))
	(setq first-sol (a-star init-node h-function cost-fn (cons (list :w_h w_h) search-options))))
    (cond ((and (solution-p first-sol)
		(solution-found first-sol) (> (solution-depth first-sol) 0))
	   (setf upper-cost-bound (solution-total-cost first-sol))
	   (setf (snode-closed (solution-last-node first-sol)) t)
	   (setf (gethash 1 hash-solutions) first-sol)

	   (store-a-star-extras node cost-fn)
	   (push node (gethash (snode-hash-code node) visited))

	   (when (> *say-output* 0) (format t "~% Running Branch & Bound [~a]" upper-cost-bound))
	   
	   (do* ((stop-this (stop-multiple node problem hash-solutions max-solutions) 
			    (stop-multiple node problem hash-solutions max-solutions)))
		((car stop-this) (when-multiple-stop (cdr stop-this) node problem)) 
	     (when (snode-closed node)  ;;Goals reached
	       (when (< (solution-total-cost (gethash (hash-table-count hash-solutions) hash-solutions)) upper-cost-bound)
		 (setf *say-solution* (gethash (hash-table-count hash-solutions) hash-solutions))
		 (setf upper-cost-bound (solution-total-cost *say-solution*))
		 (when (> *say-output* 0) 
		   (format t "~% => BnB >> Found new solution with Cost {~a}" (solution-total-cost *say-solution*))))
	       (setf node (snode-parent node)))

	     (unless (snode-expanded node) 
	       (expand-state node :helpful helpful))
	     (dolist (i-child (snode-children node))
	       (unless (snode-closed i-child)
		 (cond ((null (snode-h-value i-child))
			(setf repeated 
			      (unless exhaustive-search
				(find i-child (gethash (snode-hash-code i-child) visited) :test #'equal-state)))
			(cond ((or (not (snode-p repeated))
				   (and (snode-p repeated)
					(better-g-path repeated i-child cost-fn)))
			       (store-h-extras i-child h-function)
;; 			       (when (> *say-output* 1) (format t "~% Watch This!!!"))
			       (push i-child (gethash (snode-hash-code i-child) visited)))
			      (t
			       
			       (setf (snode-closed i-child) t)
;; 			       (when (> *say-output* 1) 
;; 				 (format t "~% == BnB ==>> Not evaluated repeated node ~a" (snode-number i-child)))
			       )))
		       (t
			(when (and (not (snode-closed i-child))
				   (not (find i-child (gethash (snode-hash-code i-child) visited) :key #'snode-number)))
			  (push i-child (gethash (snode-hash-code i-child) visited)))))
		 (when (and (not (snode-closed i-child)) (null (snode-f-value i-child)))
		   (store-a-star-extras i-child cost-fn))
		 ))
	     
;; 	     (compute-inconsistent-h-nodes node)
	     
	     (setf siblings (stable-sort (remove-if #'(lambda (i-sibling)
							(or (snode-closed i-sibling)
							    (> (snode-f-value i-sibling) upper-cost-bound)
;; 								 (or (not not-prune-inconsistent)
;; 								     (and not-prune-inconsistent
;; 									  (<= (- (snode-h-value i-sibling) (snode-h-value node))
;; 									      (snode-cost i-sibling))))
								 ))
						    (snode-children node)) 
					 #'< :key #'snode-f-value))
;; ;;======================================================================
;; 	     (format t "~%~% ===>children:")
;; 	     (map nil #'(lambda (x) (format t " ~a (~a, ~a), " (snode-number x) (snode-f-value x)
;; 					    (snode-closed x))) (snode-children node)) 
;; 	     (format t "~% ===>siblings:")
;; 	     (map nil #'(lambda (x) (format t " ~a " (snode-number x))) siblings) 
;; ;;======================================================================
	     (cond ((snode-p (car siblings))
		    (setf (snode-selected (snode-parent (car siblings))) (car siblings))
		    (setf node (car siblings)))
		   (t 
		    (setf (snode-selected node) nil)
		    (setf (snode-closed node) t)
		    (when (> *say-output* 1) (format t "~% == BnB ==>> Cost Pruning at node ~a [~a]" 
						     (snode-number node) (snode-f-value node)))
		    (setf node (if (snode-p (snode-parent node)) (snode-parent node) nil))
		    
		    ))
	     
	     (when (snode-p node)
	       (print-search-node node nil))
	     ))
	  ;; 	  In case of no solution was found
	  (t first-sol))))

;; target-selector can be: goal-regression (all goal-regression of a random node), random (a random subset of goal-regression),
;; preconds (the preconds of a given step), action (select actions instead of goals)
(defun errt-hc (init-node h-function cost-fn search-options &optional (problem *current-problem*))
  (declare (ignore cost-fn))
  (let* ((old-goals (problem-goals *current-problem*))
;;	 (extend (search-option-value :extend search-options))
;; 	 (target nil)
	 (rrt-random-state (search-option-value :rrt-random-state search-options))
	 (rrt-distance (search-option-value :rrt-distance search-options))
	 (p (search-option-value :p search-options))
	 (r (search-option-value :r search-options))
	 ;; 	(previous-state (pp-state (snode-state init-node) 'list))
	 (use-rules-p (search-option-value :use-rules-p search-options))
	 (lookahead (search-option-value :lookahead search-options))
	 (target-selector (search-option-value :target-selector search-options))
	 (helpful (search-option-value :helpful search-options))
	 ;; I am not so sure about this
;;	 (helpful (and (not (eq target-selector 'action)) (search-option-value :helpful search-options)))
	 (visited (make-hash-table))
	 (node init-node)
	 (next-node nil)
	 (actions (coerce (search-option-value :actions search-options) 'list))
	 (goal-regression (search-option-value :goal-regression search-options))
;;	 (partial-plan (if *previous-solution* (build-partial-plan *previous-solution*)))
;; 	 (actions (if partial-plan (partial-plan-actions partial-plan)))
;; 	 (goal-regression (if partial-plan (compute-goal-regression partial-plan *previous-solution*)))
	 (tree (list init-node)))
    (setf *distance-computation* (make-hash-table :test #'equal))
    (setf *computation-avoided* 0)
    (store-h-extras node h-function)
    (when (and use-rules-p *rete-root-node*)
      (push-to-rete-goals)
      (push-to-rete-object-types)
      (push-to-rete-state init-node t))
    ;;       (push-to-rete-state nil previous-state))
    ;;     (setf open-nodes (list node))
    (do* ((stop-this (stop-search node problem) (stop-search node problem)))
	(stop-this (setf *errt-tree* tree)
		   (when-stop (cdr stop-this)
			      (if (eq (cdr stop-this) :goals-reached)
				  node
				  (nearest tree old-goals rrt-distance h-function 0))
			      problem))
      (multiple-value-bind (target index)
	  (choose-target (pp-state (problem-goals *current-problem*) 'list) rrt-random-state p r goal-regression target-selector actions (snode-depth node))
	(setf (problem-goals *current-problem*) target)
	(if (not (eq target-selector :action-reuse))
	    (setq node (nearest tree target rrt-distance h-function index)))
	(when *trace-errt-p* (my-print-node node "Nearest"))
	;; the following is the expansion part of ERRT
	(if use-rules-p (prune-by-rules node))
	(if (not (snode-expanded node)) (expand-state node :helpful helpful))
	(if lookahead (expand-node-lookahead node lookahead visited))
	(push node (gethash (snode-hash-code node) visited))
	(setf next-node (choose-next-node node target-selector visited target index h-function actions p r 'errt-hc)))
      (cond ((snode-p next-node)
	     (pushnew next-node tree)
	     (setf node next-node))
	    (t
	     (dolist (i-child (restore-nonhelpful node h-function))
	       (when (find i-child (gethash (snode-hash-code i-child) visited) :test #'equal-state)
		 (setf (snode-closed i-child) t)))
	     (when (> *say-output* 1) (format t "{~% Restoring NON-Helpful Actions!!}"))
;;	     (restore-nonhelpful node h-function)
;;	     (when *trace-errt-p* (format t "{~% Restoring NON-Helpful Actions!!}"))
	     (setf next-node (hc-next-node node t))
	     (pushnew next-node tree)
	     (setf node next-node)
	     (setf (getf (snode-plist node) :expansion-reason) :current-search)))
      (if *trace-errt-p* (my-print-node node "Best"))
      (when (snode-p node)
	(print-search-node node nil))
      (if (and *rete-root-node* use-rules-p)
	  (push-to-rete-state node nil))
      (setf (problem-goals *current-problem*) old-goals))))

(defun plan (&key (algorithm nil) (heuristic nil) (cost *say-costfn*) (timeout *say-timeout*) (depthbound *say-depthbound*) (costbound *say-costbound*)
		  (helpful *say-helpful*) (w_g nil)
		  (w_h nil) (max-solutions most-positive-fixnum) (rules-file nil) (use-rules-p nil) (lookahead nil) (k-beam nil)
		  (search-options nil) (try2-search *say-2try*) (runtype nil) (special-prune nil))
  (declare (special *current-problem*)
	   (ignore try2-search))
  (let ((problem *current-problem*)
	(i-node nil)
	(algorithm-fn (if algorithm (symbol-function algorithm) (say-plan-defaults 'algorithm)))
	(heuristic-fn (if heuristic (symbol-function heuristic) (say-plan-defaults 'heuristic)))
	(cost-fn (symbol-function cost))
	(start-time (get-internal-run-time))
	(sol nil))
    ;;     (format t "~%Plan arguments: ~a ~a ~a ~a ~a ~a ~a ~a ~a ~a ~a ~a ~a ~a ~%" algorithm heuristic cost timeout depthbound helpful
    ;; 	    w_g w_h max-solutions rules-file use-rules-p lookahead search-options try2-search)
    (set-sayp :say-timeout timeout)
    (set-sayp :say-depthbound depthbound)
    (set-sayp :say-costbound costbound)

    (reset-ehc-trace)
    (sayout-initialize)
    (set-duplicate-hashing)
    (setf i-node (initialize-current-problem))
    (setf (getf (problem-plist problem) :initial-pre-time) start-time)
    (setf (getf (problem-plist problem) :initial-search-time) (get-internal-run-time))
    (setf  *search-failed* nil)
    ;; this is DB trying to do sme debugging and accessing tree
    (if *trace-errt-p* (setf *top-level-node* i-node))
    ;; this is needed for ERRT
    ;;    (setf *previous-solution* (if *say-solution* (solution-path *say-solution*)))
    (setf *say-solution* nil)
    (setf *say-hash-solutions* nil)
    ;; Loads the control rules from the file and builds the rete net
    (when (and use-rules-p rules-file)
      (format t "~2%Building RETE net...")
      (load-rules-build-rete rules-file)
      (format t " done~%")
      (push (list :use-rules-p t) search-options))
    (push (list :helpful helpful) search-options)
    (if (numberp max-solutions)
      (push (list :max-solutions max-solutions) search-options))
    (if (and w_g (not (search-option-value :w_g search-options)))
      (push (list :w_g w_g) search-options))
    (if (and w_h (not (search-option-value :w_h search-options)))
      (push (list :w_h w_h) search-options))
    (if lookahead
      (push (list :lookahead lookahead) search-options))
    (if k-beam (push (list :k-beam k-beam) search-options))

    (sayout-search t algorithm heuristic cost)
    (setf sol (funcall algorithm-fn i-node heuristic-fn cost-fn search-options))
    ;;     Turning to best-first algorithm without helpful actions
    ;;     (cond ((and *search-failed* try2-search)
    ;; 	   (setf i-node (initialize-current-problem))
    ;; 	   (setf sol (best-first i-node heuristic-fn cost-fn)))
    ;; 	  (t sol))

    ))

(defun ff (init-node h-fn cost-fn search-options)
  (declare (special *ehc-solution*))
  (let ((ehc-solution (enforced-hill-climbing init-node h-fn cost-fn search-options)))
    (setf *ehc-solution* ehc-solution)
    (cond ((and ehc-solution (solution-found ehc-solution))
	   ehc-solution)
	  ((not (eq (solution-stop-reason ehc-solution) :time-bound))
	   (format t "~%Changing to A* at time ~3$" (solution-total-time ehc-solution))
	   (a-star init-node h-fn cost-fn search-options))
	  (t ehc-solution))))

;; Tries to imitate FF by first calling EHC and then A*
;; (defun ff (init-node h-fn cost-fn search-options &optional (w_g 1) (w_h 2))
;;   (declare (special *ehc-solution*))
;;   (let ((ehc-solution (enforced-hill-climbing init-node h-fn cost-fn search-options)))
;;     (setf *ehc-solution* ehc-solution)
;;     (cond ((and ehc-solution (solution-found ehc-solution))
;; 	   ehc-solution)
;; 	  ((not (eq (solution-stop-reason ehc-solution) :time-bound))
;; 	   (format t "~%Changing to A* at time ~3$" (solution-total-time ehc-solution))
;; 	   (push (list :w_g w_g) search-options)
;; 	   (push (list :w_h w_h) search-options)
;; 	   (a-star init-node h-fn cost-fn search-options))
;; 	  (t ehc-solution))))
	   ;; 	   (set-sayp :say-timeout (- (get-sayp :say-timeout) (solution-total-time ehc-solution)))
	   ;; 	   (setf (getf (problem-plist *current-problem*) :initial-search-time) (get-internal-run-time))
	   ;; 	   (format t "~%Solution EHC: ~a; ~%Solution A*: ~a" ehc-solution a-star-solution)
	   ;; 	   (incf (solution-total-time a-star-solution) (solution-total-time ehc-solution))
	   ;; 	   (incf (solution-pre-time a-star-solution) (solution-pre-time ehc-solution))
	   ;; 	   (incf (solution-search-time a-star-solution) (solution-search-time ehc-solution))
	   ;; 	   (incf (solution-num-nodes a-star-solution) (solution-num-nodes ehc-solution))
	   ;; 	   (incf (solution-evaluated-nodes a-star-solution) (solution-evaluated-nodes ehc-solution))
	   ;; 	   (format t "~%Solution EHC: ~a; ~%Solution A*: ~a" ehc-solution a-star-solution)

(defun is-metric-domain ()
  (and *current-problem*
       (problem-metric *current-problem*)
       (or (find :fluents (dom-requirements *pspace*))
	   (find :action-costs (dom-requirements *pspace*)))
       t))

;;;; ***************************************************************************
;;;;       Code for random planners. They can also take drives computation
;;;; ***************************************************************************

;; planner: random-planner (completely random), reactive-planner (selects max drive at each time), sayphi (standard FF),
;;          rrt (some probability of selecting random action, some probability of EHC)
;; probability-ehc: probability of choosing EHC for rrt
;; narrate-p: if T, it will print a narrative in natural language (see narrate funcion below)
;; iterations: number of random steps when computing a random plan
;; number-plans: if we want to obtain a set of plans
;; Use as: (narrative-planner 'random-planner 'narrative "n-sims-1-b.pddl") or
;;         (narrative-planner 'rrt "policiaco" "new-policiaco1.pddl" :domain-file "new-policiaco.pddl" :timeout 10)
;;         (narrative-planner 'reactive-planner 'narrative "n-sims-1-b.pddl" :probability-ehc 0.4 :iterations 200)
(defun narrative-planner (planner domain problem &key (domain-file "domain.pddl")
				  (drives-actions *drives-actions*) (drives *drives*) (use-drives-p nil)
				  (probability-ehc 0.8) (helpful nil) (timeout *say-timeout*)
				  (iterations 100) (number-plans 1)
				  (narrate-p t))
  (say-domain domain domain-file)
  (prob problem)
  (let (solution plan previous-plan plans)
    (dotimes (i number-plans)
      (format t "~%Computing a new plan number ~d" i)
      (setq solution (plan :algorithm 'narrative-search :helpful helpful :timeout timeout
			   :search-options (list (list :planner planner) (list :probability-ehc probability-ehc) (list :iterations iterations)
						 (list :drives-actions drives-actions) (list :drives drives))))
      (setq plan (pp-solution-sayphi solution t))
      (cond ((not solution) (format t "~%No solution found. Recovering partial plan. Length plan: ~d" (length plan)))
	    ((solution-found solution) (format t "~%Solution found. Length plan: ~d" (length plan)))
	    (t (format t "~%No solution found. Recovering partial plan. Length plan: ~d" (length plan))))
      (if (and use-drives-p drives)
	  (format t "~%Final values of drives:~%~a" (mapcan #'(lambda (literal)
								(and (eq (car literal) '=)
								     (member (caadr literal) (cons 'met-val drives))
								     (list (caadr literal) (caddr literal))))
							    (pp-state (snode-state *last-node*) 'list))))
      ;; even if it did not find a solution (as in timebound or dead-end), it prints a solution
      (if narrate-p (narrate plan (and solution (solution-found solution))))
      (if (and (> number-plans 1) previous-plan)
	  (format t "~%Diversity of plan ~d and ~d: ~d" i (1- i) (compute-diversity plan previous-plan)))
      (setq previous-plan plan)
      (push plan plans)
      (free-mem))
    plans))

(defun compute-diversity (plan previous-plan)
  (length (set-difference (union plan previous-plan :test #'equal)
			  (intersection plan previous-plan :test #'equal)
			  :test #'equal)))

;; from enforced-hill-climbing
(defun narrative-search (init-node h-fn cost-fn search-options &optional (problem *current-problem*))
  (declare (ignore cost-fn))
  (let ((open-nodes nil) (open-children nil)
	(node init-node) (next-node nil) (visited (make-hash-table))
	(current-h 0) (current-h-plus 0) (better-h-node nil) (discrete-h (not (is-metric-domain)))
	(lookahead (search-option-value :lookahead search-options))
	(helpful (search-option-value :helpful search-options))
	(planner (or (search-option-value :planner search-options) 'rrt))
	(probability-ehc (or (search-option-value :probability-ehc search-options) 0.6))
	(iterations (or (search-option-value :iterations search-options) 100))
	(drives-actions (search-option-value :drives-actions search-options))
	(drives (search-option-value :drives search-options)))

    (cond (*trace-mem* 
	   (say-consed-bytes :mem-per-node (store-h-extras node h-fn))
	   (write-node-mem-info 'ehc))
	  (t (store-h-extras node h-fn)))

    (setf current-h (snode-h-value node))
    (setf current-h-plus (snode-h-plus node))
    (do* ((i 0 (1+ i))
	  (stop-this (if (eq planner 'random-planner)
			 (>= i iterations)
			 (stop-search node problem))
		     (if (eq planner 'random-planner)
			 (>= i iterations)
			 (stop-search node problem))))
;; 	   (>= (snode-depth node) (get-sayp :say-depthbound)) (>= (snode-depth node) (get-sayp :say-depthbound))))
	 (stop-this
	  (setf *last-node* node)
	  (if (or (eq planner 'random-planner) (eq planner 'rrt))
	      (setf *say-solution* (build-solution node problem (eq (cdr stop-this) :goals-reached)
						   (if (and (eq planner 'random-planner) (>= i iterations))
						       :depth-bound
						       (cdr stop-this))))
	      (when-stop (cdr stop-this) node problem)))
      
;;      (trace-search-extras (snode-number node))
      (expand-state node :helpful helpful)
      (when lookahead (expand-node-lookahead node lookahead visited))

      (print-search-node node nil)

      ;; just in case I need it for some kind of obscure reason
;;      (setf better-h-node (get-enforced-heuristic node h-fn current-h visited :discrete discrete-h :current-h-plus current-h-plus))
      (setq better-h-node (case planner
			    (rrt (if (<= (random 1.0) probability-ehc)
				     (get-enforced-heuristic node h-fn current-h visited :discrete discrete-h :current-h-plus current-h-plus)
				     (action-random-selection node h-fn helpful)))
			    (random-planner (action-random-selection node h-fn helpful))
			    (reactive-planner (action-max-drive-selection node (snode-children node) drives-actions drives))
			    (otherwise (get-enforced-heuristic node h-fn current-h visited :discrete discrete-h :current-h-plus current-h-plus))))
;;       (format t "~%Best node: ~a; current-h: ~,2f" (gaction-planaction (snode-applied-action better-h-node)) current-h)
      (cond ((snode-p better-h-node)
	     (setf current-h (snode-h-value better-h-node))
	     (setf current-h-plus (snode-h-plus better-h-node))
	     (setf node better-h-node)
	     (setf open-nodes nil)
	     (setf open-children nil)
 	     (setf visited (reset-hash-visited node))
	     )
	    (t 
	     (setf open-children (nconc (remove-if #'snode-closed (snode-children node)) 
					open-children))
	     
	     (cond ((not (snode-p (setf next-node (pop open-nodes))))
		    (when (> *say-output* 1) (format t "  ~% [Expanding Breadth Level]"))
		    (setf open-nodes (ehc-open-nodes open-children (car (find-argument search-options :children-sort))))
		    
		    (when (null open-nodes) ;;Recuperando la poda por las helpful actions
		      (dolist (i-child (restore-nonhelpful node h-fn))
			(cond ((find i-child (gethash (snode-hash-code i-child) visited) :test #'equal-state)
			       (setf (snode-closed i-child) t))
			      (t 
			       (push i-child (gethash (snode-hash-code i-child) visited))
			       (push i-child open-nodes))))
			       
		      ;; 		      (setf open-nodes (restore-nonhelpful node h-fn))
		      
		      (when (> *say-output* 1) 
			(format t "  ~%!!Restoring NON Helpful Nodes.")))
		    (setf node (pop open-nodes))
		    (setf open-children nil))
		   (t 
		    (setf node next-node)))))       
      ;; 	 (when (snode-p node)
      ;; 	   (print-search-node node nil)
      )))

(defun action-random-selection (node h-function helpful)
  (let* ((children (snode-children node))
	 (selected-node (choose-one (if helpful
					(remove-if-not #'snode-helpful-p children)
					children))))
    (cond (selected-node
	   (store-h-extras selected-node h-function 0)
	   ;;    (format t "~%Action ~a chosen randomly" (gaction-planaction (snode-applied-action selected-node)))
	   selected-node)
	  (t node))))

;;   (let ((action (choose-one (cdr (choose-one drives-actions)))))
;;     (choose-one (or (remove-if-not #'(lambda (node) (eq action (gaction-planaction (snode-applied-action node))))
;; 				   nodes)
;; 		    nodes)))

(defun action-max-drive-selection (node nodes drives-actions drives)
  (let* ((max-drive (find-max-drive (pp-state (snode-state node) 'list) drives))
	 (action (choose-one (cdr (assoc max-drive drives-actions))))
	 (children (remove-if-not #'(lambda (node) (eq action (gaction-planaction (snode-applied-action node))))
				  nodes))
	 (best (choose-one (or children nodes))))
    (if children
	(format t "~%Action ~a chosen from max drive ~a" (gaction-planaction (snode-applied-action best)) max-drive)
	(format t "~%Action ~a chosen randomly" (gaction-planaction (snode-applied-action best))))
    best))

(defun find-max-drive (state drives)
  (let ((max-drive 0)
	(drive (car *drives*)))
    (dolist (literal state)
      (when (and (eq (car literal) '=)
		 (member (caadr literal) drives)
		 (> (caddr literal) max-drive))
	(setq max-drive (caddr literal))
	(setq drive (caadr literal))))
    drive))

(defun narrate (solution solution-found-p)
  (format t "~%")
  (dolist (action solution)
    (format t "~%")
    (case (car action)
      (move-to-kill (format t "~a goes from ~a to ~a to kill ~a"  (nth 1 action) (nth 3 action) (nth 4 action)(nth 2 action)))
      (move-to-kill-by-command (format t "~a goes from ~a to ~a to kill ~a by ~a's command"  (nth 1 action) (nth 4 action) (nth 5 action)(nth 2 action)(nth 3 action)))
      (move-to-kill-bodyguard (format t "~a goes from ~a to ~a to kill ~a , ~a's bodyguard"  (nth 1 action) (nth 4 action) (nth 5 action)(nth 3 action)(nth 2 action)))
      (move-to-kill-bodyguard-by-command (format t "~a goes from ~a to ~a to kill ~a , ~a's bodyguard, by ~a's command"  (nth 1 action) (nth 5 action) (nth 6 action)(nth 3 action)(nth 2 action)(nth 4 action)))
      (move-to-kidnap (format t "~a goes from ~a to ~a to kidnap ~a"  (nth 1 action) (nth 3 action) (nth 4 action)(nth 2 action)))
      (move-to-rob-bank (format t "~a goes from ~a to ~a to commit a bank robbery"  (nth 1 action) (nth 2 action) (nth 3 action)))
      (move-to-rob-business (format t "~a goes from ~a to ~a ,  ~a's business, to commit a robbery"  (nth 1 action) (nth 3 action) (nth 4 action)(nth 2 action)))
      (move-to-kiss (format t "~a goes from ~a to ~a to kiss ~a"  (nth 1 action) (nth 3 action) (nth 4 action)(nth 2 action)))
      (move-to-pickup-object-kill (format t "~a goes from ~a to ~a and picks up ~a to kill ~a"  (nth 1 action) (nth 3 action) (nth 4 action)(nth 5 action)(nth 2 action)))
      (move-to-pickup-object-kill-by-command (format t "~a goes from ~a to ~a and picks up ~a to kill ~a by ~a's command"  (nth 1 action) (nth 4 action) (nth 5 action)(nth 6 action)(nth 2 action)(nth 3 action)))
      (move-to-pickup-object-rob (format t "~a goes from ~a to ~a and picks up ~a to rob"  (nth 1 action) (nth 2 action) (nth 3 action)(nth 4 action)))
      (pick-up-object-to-kill (format t "~a picks up ~a at ~a to kill ~a"  (nth 1 action) (nth 4 action) (nth 3 action)(nth 2 action)))
      (pick-up-object-to-kill-by-command (format t "~a picks up ~a at ~a to kill ~a by ~a's command"  (nth 1 action) (nth 5 action) (nth 4 action)(nth 2 action)(nth 3 action)))
      (pick-up-object-to-rob (format t "~a picks up ~a at ~a to rob"  (nth 1 action) (nth 3 action) (nth 2 action)))
      (drop-object (format t "~a drops ~a at ~a" (nth 1 action) (nth 3 action) (nth 2 action)))
      (decide-murder (format t "~a decide to kill ~a for ~a" (nth 1 action) (nth 2 action) (nth 3 action)))
      (command-murder (format t "~a command ~a to kill ~a for ~a" (nth 1 action) (nth 3 action) (nth 2 action)(nth 4 action)))
      (kill (format t "~a kills ~a with ~a at ~a" (nth 1 action) (nth 2 action) (nth 4 action) (nth 3 action)))
      (kill-by-command (format t "~a kills ~a with ~a at ~a by ~a's command" (nth 1 action) (nth 2 action) (nth 5 action) (nth 4 action)(nth 3 action)))
      (kill-bodyguard (format t "~a kills ~a, ~a's bodyguard,  with ~a at ~a" (nth 1 action) (nth 3 action) (nth 2 action) (nth 5 action) (nth 4 action)))
      (kill-bodyguard-by-command (format t "~a kills ~a, ~a's bodyguard,  with ~a at ~a" (nth 1 action) (nth 3 action) (nth 2 action) (nth 5 action) (nth 4 action)))
      (failed-kill (format t "~a tries to kill ~a  at ~a , but fails. ~a gets hurt" (nth 1 action) (nth 2 action) (nth 3 action)(nth 2 action)))
      (failed-kill-by-command (format t "~a tries to kill ~a  at ~a by ~a's command, but fails. ~a gets hurt" (nth 1 action) (nth 2 action) (nth 4 action)(nth 3 action)(nth 2 action)))
      (vengeance-lover (format t "~a wants to get revenge on ~a for killing his lover ~a" (nth 3 action) (nth 2 action) (nth 1 action)))
      (vengeance-father (format t "~a wants to get revenge on ~a for killing his son ~a" (nth 3 action) (nth 2 action) (nth 1 action)))
      (kiss (format t "~a kisses ~a at ~a" (nth 1 action) (nth 2 action) (nth 3 action)))
      (discover-kissing (format t "~a discovers that ~a kissed his lover ~a and wants to get revenge on them" (nth 1 action) (nth 2 action) (nth 3 action)))
      (find-clue-object (format t "~a finds at ~a an evidence on ~a that incriminates ~a" (nth 1 action) (nth 3 action) (nth 4 action)(nth 2 action)))
      (suspect-police (format t "~a suspects that ~a killed ~a" (nth 1 action) (nth 2 action) (nth 3 action)))
      (follow (format t "~a silently chases ~a from ~a to ~a" (nth 1 action) (nth 2 action) (nth 3 action)(nth 4 action)))
      (capture (format t "~a captures ~a at ~a and sends him to ~a" (nth 1 action) (nth 2 action) (nth 3 action)(nth 4 action)))
      (escape-from-jail (format t "~a escapes from ~a " (nth 1 action) (nth 2 action)))
      (new-boss (format t "~a becomes new boss of ~a " (nth 2 action) (nth 3 action)))
      (betray (format t "~a betrays ~a and quits ~a" (nth 1 action) (nth 2 action)(nth 3 action)))
      (betray-bodyguard (format t "~a, ~a's bodyguard, betrays him and quits ~a" (nth 1 action) (nth 2 action)(nth 3 action)))
      (destroy-business (format t "~a destroys ~a, ~a's business, due to an unpaid debt with ~a" (nth 2 action) (nth 1 action)(nth 4 action)(nth 3 action)))
      (loan (format t "~a lends money to ~a " (nth 2 action) (nth 1 action)))
      (pay-debt (format t "~a pays off the debt with ~a " (nth 1 action) (nth 2 action)))
      (decide-kidnap-father-son (format t "~a decide to kidnap ~a due to an unpaid debt" (nth 1 action) (nth 2 action)))
      (decide-kidnap-lovers (format t "~a decide to kidnap ~a due to an unpaid debt" (nth 1 action) (nth 2 action)))
      (kidnap (format t "~a attacks ~a at ~a. ~a gets kidnapped by ~a" (nth 1 action) (nth 2 action)(nth 3 action)(nth 2 action) (nth 1 action)))
      (pay-rescue-father (format t "~a pays ~a for the release of his son ~a" (nth 3 action) (nth 1 action)(nth 2 action)))
      (pay-rescue-lover (format t "~a pays ~a for the release of lover ~a" (nth 3 action) (nth 1 action)(nth 2 action)))
      (decide-rob-lovers (format t "~a decide to rob in order to make money to pay ~a for the release of lover ~a" (nth 3 action) (nth 2 action)(nth 1 action)))
      (decide-rob-father-son (format t "~a decide to rob in order to make money to pay ~a for the release of son ~a" (nth 3 action) (nth 2 action)(nth 1 action)))
      (rob-business (format t "~a robs at ~a, ~a's business" (nth 1 action) (nth 3 action)(nth 2 action)))
      (rob-bank (format t "~a commits a bank robbery at ~a" (nth 1 action) (nth 3 action)))
      (no-motivation-money (format t "~a has a lot of money and won't rob in the future" (nth 1 action)))
      (travel (format t "~a travels from ~a to ~a"  (nth 1 action) (nth 2 action) (nth 3 action)))
      (move (if (<= (random 1.0) 0.5)
		(format t "~a goes from ~a to ~a"  (nth 1 action) (nth 2 action) (nth 3 action))
		(format t "~a drives carefully from ~a to ~a"  (nth 1 action) (nth 2 action) (nth 3 action))))
      (slay (format t "~a slays ~a at ~a"  (nth 1 action) (nth 2 action) (nth 3 action)))
      (summon (format t "~a summons ~a with ~a at ~a" (nth 1 action) (nth 2 action) (nth 3 action) (nth 4 action)))
      (love-spell (format t "~a sends a love spell to ~a with ~a" (nth 1 action) (nth 2 action) (nth 3 action)))
      (fall-in-love (format t "~a falls in love with ~a at ~a" (nth 1 action) (nth 2 action) (nth 3 action)))
      (marry (format t "~a marries ~a at ~a" (nth 1 action) (nth 2 action) (nth 3 action)))
      (rob (format t "~a robs ~a" (nth 1 action) (nth 2 action)))
      (kiss (format t "~a kisses ~a in ~a and ~a discovers it" (nth 1 action) (nth 2 action) (nth 4 action) (nth 3 action)))
      (kill-person-object (format t "~a kills ~a with ~a in ~a" (nth 1 action) (nth 2 action) (nth 3 action) (nth 4 action)))
      (kill-person-action (format t "~a kills ~a by ~a in ~a" (nth 1 action) (nth 2 action) (nth 4 action) (nth 3 action)))
      (drive (format t "~a drives from ~a to ~a" (nth 1 action) (nth 2 action) (nth 3 action)))
      (pick-up-object (format t "~a picks up ~a at ~a to kill ~a" (nth 1 action) (nth 3 action) (nth 2 action) (nth 4 action)))
      (drop-object (format t "~a drops ~a in ~a" (nth 1 action) (nth 3 action) (nth 2 action)))
      (clean-object (format t "~a cleans ~a in ~a" (nth 1 action) (nth 3 action) (nth 2 action)))
      (clean-place (format t "~a cleans ~a" (nth 1 action) (nth 2 action)))
      
	  (travel (format t "~a travels from ~a to ~a"  (nth 1 action) (nth 2 action) (nth 3 action)))
	  (travel-together-2 (format t "~a and ~a travel from ~a to ~a"  (nth 1 action) (nth 2 action) (nth 3 action) (nth 4 action)))
	  (travel-together-3 (format t "~a, ~a and ~a travel from ~a to ~a"  (nth 1 action) (nth 2 action) (nth 3 action) (nth 4 action) (nth 5 action)))
	  
					; OBJECTS
      (take-obj (format t "~a takes the object ~a at ~a"  (nth 1 action) (nth 2 action) (nth 3 action)))
      (drop-obj (format t "~a drops the object ~a at ~a"  (nth 1 action) (nth 2 action) (nth 3 action)))
	  (give-obj (format t "~a gives the object ~a to ~a at ~a"  (nth 1 action) (nth 3 action) (nth 2 action) (nth 4 action)))
      ;(give-obj (format t "~a gives the object ~a to ~a (now is indebted to him) at ~a"  (nth 1 action) (nth 3 action) (nth 2 action) (nth 4 action)))
      ;(give-obj-indebted (format t "~a (indebted) gives the object ~a to ~a at ~a"  (nth 1 action) (nth 3 action) (nth 2 action) (nth 4 action)))
      (trade-obj (format t "~a trades the object ~a to ~a for ~a at ~a"  (nth 1 action) (nth 3 action) (nth 2 action) (nth 4 action) (nth 5 action)))
      (loot-obj (format t "~a loots the object ~a from ~a (dead) at ~a"  (nth 1 action) (nth 3 action) (nth 2 action) (nth 4 action)))
	  
					; HURT AND KILL
      (hurt-punch (format t "~a punchs and hurts ~a at ~a"  (nth 1 action) (nth 2 action) (nth 3 action)))
      (hurt-arm (format t "~a hurts ~a at ~a with ~a"  (nth 1 action) (nth 2 action) (nth 3 action) (nth 4 action)))
      (kill-arm (format t "~a kills ~a at ~a with ~a"  (nth 1 action) (nth 2 action) (nth 3 action) (nth 4 action)))
	  
					; ANIMALS
      (kill-and-eat-animal (format t "~a (hurt) kills and eats ~a at ~a with ~a"  (nth 1 action) (nth 2 action) (nth 3 action) (nth 4 action)))
      (hurt-by-animal (format t "~a hurts ~a at ~a"  (nth 2 action) (nth 1 action) (nth 3 action)))
      (kill-by-animal (format t "~a kills ~a at ~a"  (nth 2 action) (nth 1 action) (nth 3 action)))
      (kill-animal (format t "~a kills ~a at ~a with ~a"  (nth 1 action) (nth 2 action) (nth 3 action) (nth 4 action)))
	  
					; MAGIC
      (kill-magic (format t "~a kills (magic) ~a at ~a with ~a"  (nth 1 action) (nth 2 action) (nth 3 action) (nth 4 action)))
      (heal-magic (format t "~a heals (magic) ~a (hurt) at ~a with ~a"  (nth 1 action) (nth 2 action) (nth 3 action) (nth 4 action)))
      (heal-magic-himself (format t "~a heals (magic) himself with ~a"  (nth 1 action) (nth 2 action)))
      (magic-become-invisible (format t "~a is invisible with ~a"  (nth 1 action) (nth 2 action)))
      (magic-become-visible (format t "~a is visible with ~a"  (nth 1 action) (nth 2 action)))
	  
					; MOTIVES
      (same-motive-friends (format t "~a asks his friend ~a to follow his motive ~a"  (nth 1 action) (nth 2 action) (nth 4 action)))
      ;(same-motive-indebted (format t "~a asks ~a to follow his motive ~a to pay off his debt"  (nth 1 action) (nth 2 action) (nth 4 action)))
     
   	  (make-friends-motive (format t "~a and ~a are friends because they have the motive ~a in common"  (nth 1 action) (nth 2 action) (nth 4 action)))
      (make-friends-want-kill (format t "~a and ~a are friends because they want to kill ~a"  (nth 1 action) (nth 2 action) (nth 4 action)))
      (make-friends-friends (format t "~a and ~a are friends because they are friends of ~a"  (nth 1 action) (nth 2 action) (nth 4 action)))
	  
      (make-enemy-wish-obj (format t "~a and ~a are enemies because they wish the object ~a"  (nth 1 action) (nth 2 action) (nth 4 action)))
      (make-enemy-motive (format t "~a (~a) and ~a (~a) are enemies because their motives disagree"  (nth 1 action) (nth 3 action) (nth 2 action) (nth 4 action)))
      (make-enemy-friends (format t "~a and ~a are enemies because ~a (~a's friend) and ~a are enemies"  (nth 1 action) (nth 4 action)(nth 2 action)(nth 1 action)(nth 4 action)))
      (make-enemy-kill-friend (format t "~a and ~a are enemies because ~a (~a's friend) has been killed by ~a"  (nth 1 action) (nth 2 action)(nth 4 action)(nth 1 action)(nth 2 action)))
	 
					; LEARNING
      (learn-motive (format t "~a has the motive ~a because he wants to complete his motive ~a"  (nth 1 action) (nth 3 action) (nth 2 action)))
      (learn-motive-wish-obj (format t "~a wishes the object ~a because he has the motive ~a"  (nth 1 action) (nth 3 action) (nth 2 action)))
      (learn-place-obj (format t "~a travels to ~a because he wishes the object ~a"  (nth 1 action) (nth 4 action) (nth 2 action)))
      (learn-place-obj-char (format t "~a travels to ~a because he wishes the object ~a ~a has"  (nth 1 action) (nth 5 action) (nth 3 action) (nth 2 action)))
	  (learn-place-give-obj-char (format t "~a travels to ~a because he wants to give the object ~a to ~a"  (nth 1 action) (nth 5 action) (nth 3 action) (nth 2 action)))
	  (learn-place-enemy (format t "~a travels to ~a because he wants to kill ~a"  (nth 1 action) (nth 4 action) (nth 2 action)))
	  (learn-place-food (format t "~a travels to ~a because he wants to eat a ~a"  (nth 1 action) (nth 4 action) (nth 2 action)))
	  (learn-place-heal (format t "~a travels to ~a because he wants ~a to heal him"  (nth 1 action) (nth 4 action) (nth 2 action)))
	  (learn-place-obj-be-destroyed (format t "~a travels to ~a because he wishes to destroy the object ~a"  (nth 1 action) (nth 4 action) (nth 2 action)))
	  
					; MAIN OBJECT ACTIONS
      (destroy-obj (format t "~a destroys the object ~a at ~a"  (nth 1 action) (nth 3 action) (nth 4 action)))
      (acquire-obj (format t "~a has acquired the object ~a"  (nth 1 action) (nth 3 action)))
      (kill-strong (format t "~a kills ~a at ~a with ~a"  (nth 1 action) (nth 2 action) (nth 3 action) (nth 4 action)))
	  (otherwise (format t "~a" action))))
  (if solution-found-p
      (format t "~%End.")
      (format t "~%... to be continued.")))
