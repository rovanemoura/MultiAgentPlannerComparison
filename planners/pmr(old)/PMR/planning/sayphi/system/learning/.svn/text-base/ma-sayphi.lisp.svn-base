;; Daniel Borrajo 2013-14
;;; LGPL
(in-package "COMMON-LISP-USER")
;; (asdf:oos 'asdf:load-op "cl-ppcre" :force t)

;; Input/output general variables
(defvar *solution-mapr* nil "MAPR solution")
(defvar *solution-centralized* "Standard planner solution")
(defvar *solution-cmap* nil "CMAP solution")
(defvar *merged-domain* "merged-obfuscated-domain.pddl" "Name for the merged domain")
(defvar *merged-problem* "merged-obfuscated-problem.pddl" "Name for the merged problem")
(defvar *obfuscated-domain* "merged-obfuscated.pddl" "Name for the obfuscated domain")
(defvar *obfuscated-problem* "merged-obfuscated.pddl" "Name for the obfuscated problem")

;; Auxiliary vars
(defvar *agents* nil "List of agents structure")
(defvar *private-goals* nil "List of private goals of an agent")
(defvar *public-goals* nil "List of public goals of a problem. It does not include the public goals with one of the arguments being an agent or a private instance.")
(defvar *all-public-goals* nil "List of all public goals of a problem (including the public goals with one of the arguments being an agent or a private instance.).")
(defvar *trace-ma-sayphi* nil "For debugging")
(defvar *union-preconds* nil "List of instantiated literals in preconds of actions in plans of MAPR")
(defvar *union-effects* nil "List of instantiated literals in effects of actions in plans of MAPR")
(defvar *union-costs* nil)
(defvar *plan-constants* nil "List of constants in actions in plans of MAPR")
(defvar *original-actions* nil "List of names of original actions, so that I do not anonymize them")
(defvar *anon-index* 0 "Index for anonymization")
(defvar *short-anon-p* nil "If T, it will generate short anonymize names")
(defvar *anonymize-alist* nil "Substitution (alist) for anonymizing domains and problems")
(defvar *static-predicates* nil "List of static predicates. They will be removed in actions from one agent to the next ones.")
(defvar *public-predicates-joint-actions* nil "List of predicates that belong to joint actions")
(defvar *grounded-public-predicates-joint-actions* nil "List of new predicates to be generated from joint actions")
(defvar *predicates-in-action* nil "List of predicates of a certain type in an action definition")
(defvar *internal-instances-others* nil "Private instances of other agents")
(defvar *all-params* nil "List of all params of an action including those from foralls and exists")
(defvar *agent-type* nil "Type of agent when anonymizing")
(defvar *agent-var* nil "Var of agent in non-joint actions")
(defvar *goals-assignment-time* 0)
(defvar *total-time* 0)
(defvar *preprocessing-time* 0)
(defvar *joint-actions-p* nil "If t, the domain has joint actions")
(defvar *joint-predicates* nil "If t, the domain has joint predicates")
(defvar *private-action-p* nil "If t, it will be a private action")
(defvar *init-communication-time* 0 "Used to compute the communication cost between one agent planning task and the next one")
(defvar *ma-fd-sleeptime* 300 "When running MA-FD, it waits this amount of seconds for running the next problem")
(defvar *ma-pddl-alist* nil "Alist generated by the MA-PDDL to PDDL translator for actions with multiple mixed types")
(defvar *mapr-iterations-subgoaling* nil "Number of iterations needed for solving a planning task with interacting agents with MAPR")
;; (defvar *subgoals-causal-graph* nil "Causal relationships among agents subgoals in MAPR. It is a list of sublists, where
;; each sublist is (conditions subgoals). The relation is such that in a state where conditions are met, the subgoals can
;; be reached by an agent with a relaxed plan.")
(defvar *policy* nil "Ordered list of sublists of the form (agent subgoals). It marks the order in which subgoals/goals
should be solved for solving the MAPR problem.")
(defvar *unreachable-goals* nil "If non-nil, it is the list of goals that could not be reached, detected by the
preprocessing.")
(defvar *achievable-by* nil "Alist that links agents to facts they can achieve for the first time.")
(defvar *removed-goals* nil "Auxiliary var to hold the removed goals from the policy because they were not part of the domain of a given agent")

;; from Sayphi, so that it prints nothing
(setf *say-output* 0)

(defstruct (agent (:print-function pp-agent))
  (name nil) ;; the same as in the problem file
  (type nil) ;; the corresponding type
  (assigned-goals nil) ;; list of literals
  (subgoals nil) ;; to allow MAPR solve Logistics (et al) problems
  (votes nil) ;; alist of literal goals and heuristic number
  (anonymize-list nil) ;; substitution alist: ((name1 . new-name1) ...)
  (reverse-anonymize-list nil) ;; substitution alist to be used to desobfuscate: ((new-name1 . name1) ...)
  (positions-in-actions nil) ;; alist of original action names and parameter position of agent. For des-obfuscating
  (domain-file nil) ;; string as "obfuscated-domain-satellite0.pddl"
  (problem-file nil) ;; string as ""obfuscated-satellite0.pddl"
  (mapr-domain-file nil) ;; string for mapr auxiliary files
  (mapr-problem-file nil) ;; string for mapr auxiliary files
  (predicates nil) ;; list of predicate-defs of agent domain
  (static-predicates nil) ;; list of static predicates of that agent
  (macro-operators nil) ;; alist of macro-operators and their corresponding actions
  (private-goals nil) ;; private goals of the agent
)


;; algorithms: lama-unit-cost (only first solution, unit cost), lama-first (only first solution, arbitrary cost),
;;             lama-second (second iteration and following ones of Lama-2011), lama-seq (Lama-2011),
;;             lama-opt (optimal), cgamer, metric-ff, a-star, enforced-hill-climbing, ...
;; replanning-algorithm can be: errtplan, lpg-adapt, or any of the previous algorithms
;; goal-selection can be:
;;   all-achievable: each agent will receive as goals all goals that can potentially be achieved by it
;;   rest-achievable: each agent will receive as goals all goals that can potentially be achieved by it after removing the ones already assigned to a previous agent
;;   load-balance: goals are assigned so that they are as balanced as possible
;;   best-cost: assigns each goal to the agent that potentially can achieve it with less cost: h(estado-inicial)
;;   subsets: assigns each goal to all agents that appear in its relaxed-plan
;;   contract-net: assigns first goal to best agent. Then, assigns the second goal to best agent, taking into account
;;                 that the best agent for first goal also includes second goal, and so on.
;;   all: returns all agents (full completeness)
;; internal-types is a list of types that are internal to agents
;; if run-original-centralized-p=T, it also runs the centralized approach to compare
;; if add-goals-p=T, it will add the goals of one agent to the goals of the next one. Otherwise, we would have to pass the end state of the previous agent
;; iterations: for stochastic algorithms, how many times to run each configuration
;; sort-agents: function to sort agents. names: ordering based on names, random: random order, maxgoals: decreasing
;;             order in #goals, mingoals: increasing order in #goals, subgoals: order first the ones that have to
;;             achieve the first subgoals
;; generate-subproblems-only-p: if T, it will only generate the subproblems and not run the planner
;; only-one-iteration-p: if T, it will only iterate once over all agents
;; init-agents: if NIL, it will generate the corresponding subproblems, assigning goals to agents, ....
;;              if T, it will read the agents from the file probsets-dir/agents.lisp
;;              if it is a list, it will use that agents list. It should be a list of agents where each agent is a structure of
;;                 type agent.
;;              otherwise, it assumes it is a pathname of a file where agents have been saved
;; ma-pddl-p: if T, it will assume the input domain and problem are in MA-PDDL format, and translates them into PDDL
;;             apart from reading the agent types and internal-predicates
;; max-planning-iterations: If an stochastic replanner does not solve a problem, I can run it again up to this number of
;;                          iterations
;; anytime-p: if T, it will call lama-second (~2nd and following iterations of LAMA-2011) to improve the solution
;; parallel-planning-p: if T, it assumes solve-for-merging all agents planning processes can be run in parallel
;; search-options: allows to give other inputs to the Sayphi planner.
;;     For instance: ((planner rrt) (probability-ehc 0.6) (iterations 100))
;; use-macros-p: if T, MAPR will generate a macro for each subset of private actions in an agent solution to send it to
;;             the next agent
;; only-one-macro-p: if T, it will only generate a macro per solved problem (agent)
;; output-file: string, if supplied, used to give name to results file

;; (run-ma-experiments "rover" "pfile*" '(rover) '(at can_traverse equipped_for_soil_analysis equipped_for_rock_analysis equipped_for_imaging empty
;; 						have_rock_analysis have_soil_analysis full calibrated supports available have_image store_of on_board
;; 						visible_from calibration_target)
;; 		    '(camera store) :domain-file "StripsRover.pddl" :goal-selections '(all-achievable rest-achievable best-cost load-balance)
;; 		    :run-original-centralized-p t :run-mapr-p t :run-cmap-p t
;; 		    :algorithms '(lama) :replanning-algorithms '(lama lpg-adapt) :timeout 600)

(defun run-ma-experiments (domain problems-regexp agent-types internal-predicates internal-types
			   &key (domain-dir (format nil "~a~a/" *domains-dir* domain))
			     (probsets-dir (format nil "~aprobsets/" domain-dir))
			     (domain-file "domain.pddl") (ma-pddl-p nil)
			     (init-agents nil)
			     (results-dir (format nil "~aresult/" domain-dir))
			     (output-file-prefix "") (write-output-file-p t) (fixed-output-file nil)
			     (plan-file (concatenate 'string results-dir "plan.sol"))
			     (sort-agents '(name)) (goal-selections '(best-cost))
			     (algorithms '(enforced-hill-climbing)) (replanning-algorithms '(errtplan))
			     (anytime-p nil) (anytime-algorithm 'lama-second)
			     (run-original-centralized-p t) (run-cmap-p t) (run-mapr-p t)
			     (use-macros-p nil) (only-one-macro-p nil)
			     (add-goals-p t) (parallel-plan-p t)
			     (iterations 1) (only-one-iteration-p nil) (max-iterations 5) (max-planning-iterations 5)
			     (timeout 300)
			     (generate-subproblems-only-p nil) (agents-file nil)
			     (solve-for-merging-p nil) (parallel-planning-p t)
			     (search-options nil) (init-comment "")
			     (validate-mapr-p t) (validate-obfuscated-p t))
  (format t "~2%Running domain ~a~%" domain)
  (let ((problems (mapcar #'(lambda (pathname)
			      (if (pathname-type pathname)
				  (concatenate 'string (pathname-name pathname) "." (pathname-type pathname))
				  (pathname-name pathname)))
			  (directory (format nil "~a~a" probsets-dir problems-regexp))))
	output-file)
    (ensure-directories-exist results-dir)
    (ensure-directories-exist (concatenate 'string results-dir "internal/"))
    (dolist (goal-selection goal-selections)
      (dolist (algorithm algorithms)
	(dolist (replanning-algorithm replanning-algorithms)
	  (dolist (sort-agent sort-agents)
	    (dotimes (i iterations)
	      (if (and write-output-file-p (not generate-subproblems-only-p) (not solve-for-merging-p))
		  (with-open-file (ostream (setq output-file
						 (output-file-name fixed-output-file results-dir output-file-prefix
								   problems-regexp run-cmap-p run-mapr-p
								   algorithm replanning-algorithm
								   goal-selection sort-agent use-macros-p))
					   :direction :output :if-exists :supersede :if-does-not-exist :create)
		    (format ostream ";; ~a~%;; approach problem solvedp #solved #problems/agents time nodes length~%
;; [validated-p assignment-time preprocessing-time parallelization-time makespan]~2%(" init-comment)))
	      (dolist (problem problems)
		(if (or generate-subproblems-only-p solve-for-merging-p)
		    (setq output-file (format nil "~aproblems-~a-~(~a~)-~(~a~).lisp"
					      results-dir (pathname-name problem) goal-selection sort-agent))
		    (if *trace-ma-sayphi*
			(format t "~%Running ~(~a~) ~(~a~) ~(~a~) ~d" algorithm replanning-algorithm
				goal-selection iterations)))
		(run-ma domain problem agent-types internal-predicates internal-types
			:domain-dir domain-dir :probsets-dir probsets-dir :domain-file domain-file :results-dir results-dir
			:init-agents init-agents :ma-pddl-p ma-pddl-p
			:use-macros-p use-macros-p :only-one-macro-p (and use-macros-p only-one-macro-p)
			:goal-selection goal-selection :timeout timeout
			:algorithm algorithm :replanning-algorithm replanning-algorithm
			:anytime-p anytime-p :anytime-algorithm anytime-algorithm
			:run-original-centralized-p run-original-centralized-p
			:run-cmap-p run-cmap-p :run-mapr-p run-mapr-p
			:add-goals-p add-goals-p :output-file (and write-output-file-p output-file) :plan-file plan-file
			:parallel-plan-p parallel-plan-p
			:validate-obfuscated-p validate-obfuscated-p :validate-mapr-p validate-mapr-p
			:only-one-iteration-p only-one-iteration-p :sort-agents sort-agent
			:max-planning-iterations max-planning-iterations :max-iterations max-iterations
			:generate-subproblems-only-p generate-subproblems-only-p :agents-file agents-file
			:solve-for-merging-p solve-for-merging-p :parallel-planning-p parallel-planning-p
			:search-options search-options))
	      (if (and write-output-file-p (not generate-subproblems-only-p) (not solve-for-merging-p))
		  (with-open-file (ostream output-file :direction :output :if-exists :append :if-does-not-exist :create)
		    (format ostream "~%)")))
	      ;; so it does not run again the centralized approach from the second one, given that results will be the same
	      (setf run-original-centralized-p nil))))))))

(defun output-file-name (output-file results-dir output-file-prefix problems-regexp run-cmap-p run-mapr-p
				     algorithm replanning-algorithm goal-selection sort-agent use-macros-p)
  (if output-file
      (format nil "~a~a" results-dir output-file)
      (format nil "~a~a~a-~(~a~a~a-~a-~a-~a-~a~).lisp"
	      results-dir output-file-prefix
	      (pathname-name (remove #\* problems-regexp))
	      (if run-mapr-p "mapr-" "")
	      (if run-cmap-p "cmap-" "")
	      (case algorithm
		(lama-unit-cost 'luc)
		(lama-first 'lf)
		(lpg-adapt 'lpga)
		(otherwise algorithm))
	      (case replanning-algorithm
		(lama-unit-cost 'luc)
		(lama-first 'lf)
		(lpg-adapt 'lpga)
		(otherwise replanning-algorithm))
	      (case goal-selection
		(all-achievable 'aa)
		(rest-achievable 'ra)
		(load-balance 'lb)
		(best-cost 'bc)
		(contract-net 'cn)
		(otherwise goal-selection))
	      (case sort-agent
		(mingoals 'ming)
		(maxgoals 'maxg)
		(otherwise sort-agent))
	      (if run-mapr-p (if use-macros-p 'mac 'nomac) ""))))

;; (run-ma "port" "pfile.pddl" '(hoist) '(lifting assigned available on-ship) '(pallet-ship) :domain-file "domain.pddl" :goal-selection 'all-achievable :run-original-centralized-p t :algorithm 'lama-first :timeout 200)
;; output-file: nil (no output in file) or a absolute pathname (where to save results)
;; It returns a solution or NIL. As a side effect, it returns the obfuscated domain and problem used for solving the
;; last planning task in the variables *obfuscated-domain* and *obfuscated-problem*
(defun run-ma (domain problem agent-types internal-predicates internal-types
	       &key (domain-dir (format nil "~a~a/" *domains-dir* domain))
		 (probsets-dir (format nil "~aprobsets/" domain-dir))
		 (domain-file "domain.pddl") (ma-pddl-p nil)
		 (init-agents nil)
		 (results-dir (format nil "~aresult/" domain-dir))
		 (goal-selection 'all-achievable) (parallel-plan-p nil)
		 (algorithm 'enforced-hill-climbing) (replanning-algorithm 'errtplan)
		 (anytime-p nil) (anytime-algorithm 'lama-second)
		 (run-original-centralized-p t) (run-cmap-p t) (run-mapr-p t)
		 (add-goals-p t) (only-one-iteration-p nil) (max-iterations 5)
		 (sort-agents 'name) (max-planning-iterations 5)
		 (timeout 300) (use-macros-p run-mapr-p) (only-one-macro-p t)
		 (generate-subproblems-only-p nil) (agents-file nil)
		 (solve-for-merging-p nil) (parallel-planning-p t)
		 (validate-obfuscated-p t) (validate-mapr-p t)
		 (search-options nil)
		 (plan-file (concatenate 'string results-dir "plan.sol"))
		 (output-file (format nil "~ama-result-~(~a~)-~(~a~)-~(~a~).lisp"
				      results-dir algorithm replanning-algorithm goal-selection)))
  (setf *goals-assignment-time* 0)
  (setf *total-time* 0)
  (setf *preprocessing-time* 0)
  (setf *agents* nil)
  (setf *policy* nil)
  (setf *achievable-by* nil)
  (setf *unreachable-goals* nil)
;;  (setf *internal-instances* nil)
  ;; just in case I need it
  (setf *domains-dir* (build-domains-dir domain-dir))
  (setf *domain-dir* domain-dir)
  (setf *results-pathname* results-dir)
  (ensure-directories-exist *results-pathname*)
  (ensure-directories-exist (concatenate 'string *results-pathname* "internal/"))
  ;; for compatility with IPSS
  (setf *domain-name* domain)
  (setf *anon-index* 0)
  (if (and output-file (not (probe-file output-file)))
      (with-open-file (ostream output-file :direction :output :if-exists :supersede :if-does-not-exist :create)))
  (let* ((init-time 0)
	 (assignment-time 0)
	 (solution nil)
	 (solution-domain-problem nil)
	 (solution-centralized nil)
	 (agent-privacy nil)
	 (new-domain-file domain-file)
	 (new-problem-file problem))
    (when ma-pddl-p
      (setq new-domain-file (concatenate 'string "codmap-" (pathname-name domain-file) "." (pathname-type domain-file)))
      (setq new-problem-file (concatenate 'string "codmap-" (pathname-name problem) "." (pathname-type problem)))
      (setq agent-privacy (ma-pddl-to-pddl domain-file domain-dir problem probsets-dir new-domain-file new-problem-file
					   agent-types internal-predicates))
      (setq agent-types (car agent-privacy))
      (setq internal-predicates (cadr agent-privacy)))
    (cond (init-agents (setf *agents* (get-init-agents (if (eq init-agents t)
							   (concatenate 'string results-dir "agents.lisp")
							   init-agents)))
		       (setq init-time (get-internal-real-time)))
	  ((or run-cmap-p run-mapr-p solve-for-merging-p generate-subproblems-only-p)
	   (setq init-time (get-internal-real-time))
	   ;; generates an obfuscated problem and domain for each agent and sets *agents* list to a list of agent
	   ;; structures
	   (preprocess-ma-problem domain new-problem-file agent-types
				  internal-predicates internal-types
				  :domain-dir domain-dir :domain-file new-domain-file
				  :probsets-dir probsets-dir
				  :generate-merged-domain-problem-p (or generate-subproblems-only-p
									(eq goal-selection 'contract-net)
									(eq goal-selection 'subsets)))
	   (setf *preprocessing-time* (elapsed-time init-time 'real-time))
	   (if *trace-ma-sayphi* (format t "~2%MAP compilation time: ~,2f" *preprocessing-time*))
	   (setq init-time (get-internal-real-time))
	   (setf *mapr-iterations-subgoaling* max-iterations)
	   ;; allocates goals to agents. It sets the assigned-goals attribute of agents
	   (goal-allocation internal-predicates goal-selection sort-agents domain probsets-dir domain-dir run-mapr-p)
	   (if (or run-cmap-p solve-for-merging-p)
	       (obfuscate-merged-domain-problem domain-dir probsets-dir))
	   (setq assignment-time (elapsed-time init-time 'real-time))
	   (setf *goals-assignment-time* assignment-time))
	 ;; I do not assign public goals if it is going only to execute the standard planner and no MAPR, CMAP, ...
	  (t (setq init-time (get-internal-real-time))))
	 ;; time-per-agent
;;    (setf *anonymize-alist* (mapcar #'(lambda (agent) (list agent nil nil nil)) *agents*))
    (when *trace-ma-sayphi*
      (format t "~2%Agents to be used: ~a" *agents*)
      (format t "~%Assigned goals and subgoals")
      (pp-agents :properties '(assigned-goals subgoals)))
    (cond (*unreachable-goals*
	   (format t "~2%Unsolvable problem ~a.~%  Goals that could not be reached: ~a" problem *unreachable-goals*)
	   (setf *solution-mapr* nil *solution-cmap* nil *solution-centralized* nil))
	  ((not *agents*)
	   (if (or run-cmap-p run-mapr-p solve-for-merging-p)
	       (format t "~%No agents are able to solve the problem~%"))
	   (cond (run-original-centralized-p
		  (write-message "Running standard algorithm ~a on problem ~a" t algorithm problem)
		  (setq solution-centralized (run-original-centralized domain new-domain-file new-problem-file algorithm
								       probsets-dir output-file timeout domain-dir
								       parallel-plan-p agent-types))
		  (setq solution solution-centralized))
		 (t (if (and output-file run-mapr-p)
			(with-open-file (ostream output-file :direction :output :if-exists :append :if-does-not-exist :create)
			  (format ostream "~%(multi-agent ~a nil  0 0 0.00 0 0 nil 0)" (pathname-name problem))))
		    nil)))
	  (solve-for-merging-p (solve-for-merging domain algorithm timeout
						  probsets-dir domain-dir output-file
						  *agents* parallel-planning-p))
	  (generate-subproblems-only-p (pp-agents :ofile (or agents-file
							     (concatenate 'string *results-pathname* "agents.lisp"))
						  :properties :all))
	  ((> (- timeout (elapsed-time init-time 'real-time)) 0)
	   (when run-mapr-p
	     (write-message "Running MAPR on problem ~a, ~a, ~a, ~a" t problem algorithm goal-selection sort-agents)
	     (setq solution-domain-problem (run-mapr domain new-domain-file new-problem-file timeout init-time
						     (max max-iterations *mapr-iterations-subgoaling*)
						     add-goals-p only-one-iteration-p internal-predicates
						     algorithm replanning-algorithm
						     probsets-dir output-file
						     validate-mapr-p assignment-time domain-dir max-planning-iterations
						     parallel-plan-p anytime-p anytime-algorithm search-options
						     use-macros-p only-one-macro-p plan-file))
	     (setq solution (car solution-domain-problem))
	     (when solution
	       (setf *obfuscated-domain* (cadr solution-domain-problem))
	       (setf *obfuscated-problem* (caddr solution-domain-problem))))
	   (when run-cmap-p
	     (write-message "Running CMAP on problem ~a, ~a, ~a, ~a" t problem algorithm goal-selection sort-agents)
	     (setq solution-domain-problem (run-cmap algorithm domain new-domain-file new-problem-file probsets-dir timeout output-file
						     assignment-time validate-obfuscated-p domain-dir parallel-plan-p
						     anytime-p anytime-algorithm search-options (get-internal-real-time)
						     plan-file))
	     (when (and (not solution) (car solution-domain-problem))
	       (setf *obfuscated-domain* (cadr solution-domain-problem))
	       (setf *obfuscated-problem* (caddr solution-domain-problem)))
	     (setq solution (or solution (car solution-domain-problem))))
	   (when run-original-centralized-p
	     (write-message "Running ~a on problem ~a" t algorithm problem)
	     (setq solution-centralized (run-original-centralized domain new-domain-file new-problem-file algorithm probsets-dir
								  output-file timeout domain-dir parallel-plan-p agent-types))
	     (setq solution (or solution solution-centralized)))
	   (setf *total-time* (elapsed-time init-time 'real-time))
	   (or solution 'no-solution))
	  (t (format t "~%Too much time on computing subproblems")
	     'no-time))))

(defun get-init-agents (init-agents)
  (cond ((listp init-agents) init-agents)
	((stringp init-agents)
	 (mapcar #'(lambda (agent)
		     (make-agent :name (nth 0 agent)
				 :type (nth 1 agent)
				 :assigned-goals (nth 2 agent)
				 :votes (nth 3 agent)
				 :anonymize-list (nth 4 agent)
				 :reverse-anonymize-list (nth 5 agent)
				 :positions-in-actions (nth 6 agent)
				 :domain-file (nth 7 agent)
				 :problem-file (nth 8 agent)
				 :mapr-domain-file (nth 9 agent)
				 :mapr-problem-file (nth 10 agent)
				 :predicates (nth 11 agent)
				 :subgoals (nth 12 agent)))
		 (read-file init-agents)))
	(t nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Given a single agent problem and domain and a list of agent-types, it generates a problem for each agent of
;;; agent-type in the problem
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; example: (preprocess-ma-problem "ma-rovers" "original-p03.pddl" '(rover) '(at can_traverse equipped_for_soil_analysis
;; equipped_for_rock_analysis equipped_for_imaging empty have_rock_analysis have_soil_analysis full calibrated supports
;; available have_image store_of calibration_target on_board visible_from) '((rover0 camera1 rover0store) (rover1
;; camera0 rover1store)) :domain-file "original-domain.pddl")
(defun preprocess-ma-problem (domain problem agent-types internal-predicates internal-types
			      &key (domain-dir (format nil "~a~a/" *domains-dir* domain))
				(probsets-dir (format nil "~a/probsets/" domain-dir))
				(domain-file "original-domain.pddl") (generate-merged-domain-problem-p nil))
  (declare (special *agents*))
  (setf *agents* nil)
  (write-message "Preprocessing domain ~a and problem ~a" nil domain problem)
  (let* ((problem-def (cdr (read-all-file (concatenate 'string probsets-dir problem))))
	 (agents (give-me-agents-from-problem problem-def agent-types))
	 (state (find-argument problem-def :init))
	 (goals (give-me-all-goals problem-def))
	 (internal-instances (compute-internal-instances (process-instances (find-argument problem-def :objects))
							 internal-types state agents)))
    (write-ma-problems-domains problem agents agent-types
			       internal-predicates internal-types internal-instances
			       domain-dir probsets-dir domain-file problem-def generate-merged-domain-problem-p)))
;;     (setf *public-goals* (public-goals goals agents internal-predicates internal-instances))))

;; It returns the list of public goals, which does not include those goals that include as argument an agent or an
;; internal instance of one agent. It also computes those goals that are are public goals, including the previous ones.
;; (defun public-goals (goals agents internal-predicates internal-instances)
;;   (setf *all-public-goals* nil)
;;   (mapcan #'(lambda (goal)
;; 	      (let* ((internal-goal-p (member (car goal) internal-predicates))
;; 		     (internal-instances-p (intersection (cdr goal) internal-instances))
;; 		     (private-p (or internal-goal-p internal-instances-p))
;; 		     (agents-inside (give-me-agents-in-literal (cdr goal) agents))
;; 		     (agents-names (mapcar #'agent-name *agents*)))
;; 		(if (not private-p)
;; 		    (if *joint-actions-p*
;; 			(if (member (car goal) *public-predicates-joint-actions*)
;; 			    (if agents-inside
;; 				(list (cons (rename (car goal) agents-inside t)
;; 					    (remove-agents (cdr goal) agents-inside)))
;; 				(list goal))
;; 			    (if (not agents-inside)
;; 				(list goal)))
;; 			(if (not agents-inside)
;; 			    (list goal))))))
;; 	  goals))

;; (defun public-goals (goals agents internal-predicates internal-instances)
;;   (setf *all-public-goals* nil)
;;   (mapcan #'(lambda (goal)
;; 	      (let* ((internal-goal-p (member (car goal) internal-predicates))
;; 		     (internal-instances-p (intersection (cdr goal) internal-instances))
;; 		     (private-p (or internal-goal-p internal-instances-p))
;; 		     (agents-inside (give-me-agents-in-literal (cdr goal) agents))
;; 		     (agents-names (mapcar #'agent-name *agents*)))
;; 		(if (not private-p)
;; 		    (if *joint-actions-p*
;; 			(if (member (car goal) *public-predicates-joint-actions*)
;; 			    (if agents-inside
;; 				(list (cons (rename (car goal) agents-inside t)
;; 					    (remove-agents (cdr goal) agents-inside)))
;; 				(list goal))
;; 			    (if (not agents-inside)
;; 				(list goal)))
;; 			(if (not agents-inside)
;; 			    (list goal))))))
;; 	  goals))


;; It returns the list of agents from a problem-def
(defun give-me-agents-from-problem (problem-def agent-types)
  (let ((instances (process-instances (find-argument problem-def :objects))))
    (mapcan #'(lambda (agent-type)
		(copy-list (cdr (assoc agent-type instances))))
	    agent-types)))

;; agents is a list of names, not structures, because we did not create yet the agents
;; it returns an alist for each agent of instances of internal-types that appear on a literal of the state together with
;; the agent, or they appear together with another internal instance.  I am not sure it will work in general

(defun compute-internal-instances (instances-def internal-types state agents)
  (do* ((internal-instances (mapcar #'list agents))
	(literals state)
	(literal (car literals) (car literals))
	(agent-def nil)
	(new-internal-p t))
       ((and (null literals) (not new-internal-p))
	internal-instances)
    (setq new-internal-p nil)
    (setq agent-def (find-if #'(lambda (agent) (intersection (cdr literal) agent)) internal-instances))
    (cond (agent-def
	   (dolist (arg (cdr literal))
	     (when (and (not (member arg agent-def))
			(member (object-type arg instances-def) internal-types))
	       (setq new-internal-p t)
	       (push arg (cdr (assoc (car agent-def) internal-instances)))))
	   (setq literals (if new-internal-p state (cdr literals))))
	  (t (setq literals (cdr literals))))))

(defun object-type (object instances-def)
  (some #'(lambda (instance-def)
	    (if (member object (cdr instance-def))
		(car instance-def)))
	instances-def))

;; It generates an obfuscated domain and problem for each agent. In theory, these problems are the inputs of all
;; multi-agent planning systems. But, since we do not have them right now in a standard language, I generate them from
;; standard PDDL domain and problem files
;; side-effect: it generates the list of agents and one structure per agent
(defun write-ma-problems-domains (problem agents agent-types internal-predicates internal-types internal-instances
				  domain-dir probsets-dir domain-file problem-def generate-merged-domain-problem-p)
  (declare (special *anonymize-alist* *agent-type*))
  (let* ((domain-def (cdr (read-all-file (concatenate 'string domain-dir domain-file))))
	 (types (process-types (find-argument domain-def :types)))
	 ;; list of super-types of the agent types
	 (super-types (super-types-of-set agent-types types))
	 new-problem)
    (analysis-joint-actions domain-def super-types internal-predicates)
    (setf *public-goals* nil)
    (setf *all-public-goals* nil)
    (dolist (agent agents)
      (setf *anonymize-alist* nil)
      (setf *agent-type* nil)
      (setf *private-goals* nil)
      (setq new-problem (obfuscate-problem internal-predicates internal-types internal-instances
					   problem agents agent agent-types probsets-dir problem-def))
      (push (make-agent :name agent
			:type *agent-type*
			:problem-file new-problem
			:private-goals *private-goals*
			:anonymize-list *anonymize-alist*)
	    *agents*))
    (obfuscate-domain internal-predicates internal-types agent-types domain-def domain-dir)
    (dolist (agent *agents*) (regularize-problem agent probsets-dir domain-dir types))
    (if generate-merged-domain-problem-p (obfuscate-merged-domain-problem domain-dir probsets-dir))))
;; I think I have solved both issues
      ;; *anonymize-alist* does not neccesarily have the same structure as the one used by MAPR. It is used to
      ;; des-obfuscate the solution
      ;; I need to do first new-problem to know to which type each agent belongs. It is stored in
      ;; *agent-type*
      ;; I cannot later des-obfuscate properly because I recompute the *agent-type* for each problem. I
      ;; would have to save them. Also, in case we would need them later on, we would need to save the
      ;; domains and problems

(defun analysis-joint-actions (domain-def agent-types internal-predicates)
  (setf *joint-predicates* (joint-predicates domain-def agent-types))
  (setf *joint-actions-p* nil)
  (setf *predicates-in-action* nil)
  (let ((agent-params nil))
    (dolist (action (give-me-all-actions domain-def))
      (setq agent-params nil)
      (do ((params (cleanup-params (nth 3 action)) (cdddr params)))
	  ((null params))
	(if (member (caddr params) agent-types)
	    (push (car params) agent-params)))
      (when (> (length agent-params) 1) ;; joint action
	(setf *joint-actions-p* t)
	;; collect predicates inside joint actions that have some parameter of agent type
 	(collect-predicates (nth 5 action) #'(lambda (exp)
						      (and (not (member (car exp) internal-predicates))
							   (intersection (cdr exp) agent-params))))
	(collect-predicates (nth 7 action)  #'(lambda (exp)
						       (and (not (member (car exp) internal-predicates))
							    (intersection (cdr exp) agent-params))))))
    (setf *public-predicates-joint-actions* (remove-duplicates (mapcar #'car *predicates-in-action*)))))

;; a joint action has at least two parameters that are agent-types
(defun joint-action-p (action agent-types)
  (> (count-if #'(lambda (parameter) (member parameter agent-types))
	       (nth 3 action))
     1))

;; returns a list of joint predicates of the domain. They will be used not to remove them from the goals and states of
;; agents. A joint predicate is such that it has at least 2 parameters of agent-types
(defun joint-predicates (domain-def agent-types)
  (mapcar #'car (remove-if #'(lambda (predicate-def)
			       (< (count-if #'(lambda (parameter) (member parameter agent-types))
					    (cdr predicate-def))
				  2))
			   (append (find-argument domain-def :predicates)
				   (find-argument domain-def :functions)))))

;; collects in *predicates-in-action* all predicates that fullfil a given property
(defun collect-predicates (exp membership-fn)
  (case (car exp)
    ((and or) (collect-predicates (cdr exp) membership-fn))
    (not (collect-predicates (cadr exp) membership-fn))
    ((increase assign <= >= + * - / < > when)
     (collect-predicates (cadr exp) membership-fn)
     (if (listp (caddr exp))
	 (collect-predicates (caddr exp) membership-fn)))
    ((forall exists) (collect-predicates (caddr exp) membership-fn))
    (otherwise ;; I hope list of literals or individual literal
     (cond ((listp (car exp))
	    (dolist (literal exp) (collect-predicates literal membership-fn)))
	   ((eq (car exp) '=))
	   ((funcall membership-fn exp)
	    (pushnew exp *predicates-in-action* :test #'equal))
	   (t nil)))))

;; internal-instances is an alist of agents - their internal instances
(defun obfuscate-problem (internal-predicates internal-types internal-instances problem
				 agents agent agent-types probsets-dir
				 &optional (problem-def (cdr (read-all-file (concatenate 'string probsets-dir problem)))))
  (setf *internal-instances-others* nil)
  (let* ((new-problem (if (pathname-type problem)
			  (format nil "obfuscated-~a-~(~a~).~a" (pathname-name problem) agent (pathname-type problem))
			  (format nil "obfuscated-~a-~(~a~)" (pathname-name problem) agent)))
	 (instances (process-instances (find-argument problem-def :objects)))
	 (state (find-argument problem-def :init))
	 (new-instances (obfuscate-instances instances agent agent-types internal-types internal-instances))
	 (instances-alist *anonymize-alist*)
	 (private-instances (mapcar #'cdr instances-alist))
	 (new-state (obfuscate-literals (sublis instances-alist state) agent agents internal-predicates
					private-instances nil))
	 (goals (sublis instances-alist (give-me-all-goals problem-def)))
	 (new-goals (obfuscate-literals goals agent agents internal-predicates private-instances t)))
    (write-pddl-file (pathname-name new-problem) (car (find-argument problem-def :domain))
		     (flatten-instances new-instances) new-state new-goals
		     (concatenate 'string probsets-dir new-problem)
		     (sublis *anonymize-alist* (find-argument problem-def :metric)))
    new-problem))

;; it returns the new instances-def after privatizing (obfuscating) instances of agent.
;; side-effect: all calls to anonymize-name change the anonymize-list
(defun obfuscate-instances (instances agent agent-types internal-types internal-instances)
  (declare (special *internal-instances-others* *agent-type*))
  (let* ((internal-instances-agent (cdr (assoc agent internal-instances)))
	 (internal-others (remove (assoc agent internal-instances) internal-instances :test #'equal))
	 new-name new-type new-instances)
    (setf *internal-instances-others* (mapcan #'(lambda (instance-def) (copy-list instance-def)) internal-others))
    (dolist (instance-def instances)
      (cond ((member (car instance-def) agent-types)
;;	     (if (or *joint-actions-p* *joint-predicates-p*) (push instance-def new-instances))
	     (if (member agent (cdr instance-def)) (setf *agent-type* (car instance-def))))
	    ((member (car instance-def) internal-types)
	     (setq internal-instances nil)
	     (dolist (instance (cdr instance-def))
	       (when (or (member instance internal-instances-agent) ;; private of agent
			 ;; or public
			 (not (member instance internal-others :test #'(lambda (i l) (member i l)))))
		 (setq new-name (anonymize-name instance (list agent) t))
		 (push new-name internal-instances)))
	     (setq new-type (anonymize-name (car instance-def) (list agent) t))
	     (if internal-instances (push (cons new-type internal-instances) new-instances)))
	    (t (push instance-def new-instances))))
    new-instances))

;; I assume the arguments of literals have already been anonymized
;; I assume someone has already computed the *internal-instances-others*
(defun obfuscate-literals (literals agent agents internal-predicates private-instances goals-p)
  (mapcan #'(lambda (literal)
	      (let* ((formula-p (eq (car literal) '=))
		     (internal-literal-others-p
		      (if formula-p
			  (or (internal-literal-others-p (cadr literal) agent agents internal-predicates)
			      (internal-literal-others-p (caddr literal) agent agents internal-predicates))
			  (internal-literal-others-p literal agent agents internal-predicates)))
		     (new-literal
		      (if (not internal-literal-others-p)
			  (if formula-p
			      (list '= (obfuscate-literal (cadr literal) agent agents internal-predicates private-instances
							  goals-p)
				    (caddr literal))
			      (obfuscate-literal literal agent agents internal-predicates private-instances goals-p)))))
		(if (and new-literal
			 (not (and formula-p (null (cadr new-literal)))))
		    (list new-literal))))
	  literals))

(defun internal-literal-others-p (literal agent agents internal-predicates)
  (let ((private-instances (set-difference *internal-instances-others* agents)))
    (if (consp literal)
	(or (and (member (car literal) internal-predicates)
		 (intersection agents (cdr literal))
		 (not (member agent (cdr literal))))
	    (some #'(lambda (arg) (member arg private-instances))
		  (cdr literal))))))

;; I assume it should be a public literal or a private literal of the agent
;; I remove agents as arguments. I leave internal instances
(defun obfuscate-literal (literal agent agents internal-predicates private-instances goals-p)
  (let* ((agents-in-literal (give-me-agents-in-literal (cdr literal) agents))
	 (other-agents-in-literal (remove agent agents-in-literal))
	 (private-instances-in-literal (remove-if-not #'(lambda (arg) (member arg private-instances)) (cdr literal)))
	 (agent-in-literal-p (member agent agents-in-literal))
	 (internal-p (member (car literal) internal-predicates))
	 (renamed-p nil)
	 (new-predicate (cond (internal-p
			       (anonymize-name (car literal) (list agent) t))
			      (*joint-actions-p*
			       (cond (other-agents-in-literal
				      (when (member (car literal) *public-predicates-joint-actions*)
					(setq renamed-p t)
					(rename (car literal) agents-in-literal t)))
				     ((or agent-in-literal-p private-instances-in-literal)
				      (setq renamed-p t)
				      (rename (car literal) (list agent) t))
				     (t (car literal))))
			      (other-agents-in-literal nil)
			      ((or agent-in-literal-p private-instances-in-literal)
			       (setq renamed-p t)
			       (rename (car literal) (list agent) t))
			      (t (car literal))))
	 (new-literal (if new-predicate
			  (cons new-predicate (remove-agents (cdr literal) agents-in-literal)))))
    (if (and goals-p new-literal)
	(if internal-p
	    (push new-literal *private-goals*)
	    (cond (renamed-p (pushnew new-literal *all-public-goals* :test #'equal))
		  (t (pushnew new-literal *all-public-goals* :test #'equal)
		     (pushnew new-literal *public-goals* :test #'equal)))))
    new-literal))

(defun remove-agents (args agents)
  (remove-if #'(lambda (arg) (member arg agents)) args))

(defun give-me-agents-in-literal (args agents)
   (remove-if-not #'(lambda (arg) (member arg agents)) args))

;; returns an anonymized name and includes it in the alist
(defun anonymize-name (name agents include-in-alist-p &optional (anon-prefix "anon"))
  (let ((new-name (intern (if *short-anon-p*
			      (format nil "~:@(~{~a~^-~}~)" (cons name agents))
			      (format nil "~:@(~{~a~^-~}~)" (cons anon-prefix (cons name agents)))))))
    (if include-in-alist-p (pushnew (cons name new-name) *anonymize-alist* :test #'equal))
    new-name))
;;  (let ((new-name (intern (format nil "~:@(anon-~a-~d~)" (string-trim "#:G" (gensym))))))
;;   (let ((new-name (intern (format nil "~:@(anon-~a-~a~)" agent name))))

;; (defun agents-string (agents)
;;   (let ((new-string (format nil "~:@(~a~)" (car agents))))
;;     (dolist (agent (cdr agents))
;;       (setq new-string (format nil "~:@(~a-~a~)" new-string agent)))
;;     new-string))

(defun rename (name agents include-in-alist-p)
  (anonymize-name name agents include-in-alist-p "rename"))

;; removes all literals from state and goals that were not defined in the domain of that agent (usually public literals
;; from other agents that do not appear in joint actions of the agent)
(defun regularize-problem (agent probsets-dir domain-dir types)
  (let* ((problem-file (agent-problem-file agent))
	 (predicates (agent-predicates agent))
	 (problem-def (cdr (read-all-file (concatenate 'string probsets-dir problem-file))))
	 (instances (find-argument problem-def :objects))
	 (objects (process-instances instances))
	 (state (find-argument problem-def :init))
	 (new-state (remove-invalid-predicates state predicates types objects))
	 (goals (give-me-all-goals problem-def))
	 (new-goals (remove-invalid-predicates goals predicates types objects)))
    (if *trace-ma-sayphi*
	(format t "~2%Regularizing agent ~a~%Removed literals from state:~%~a~%Removed literals from goals:~% ~a"
		agent (set-difference state new-state :test #'equal) (set-difference goals new-goals :test #'equal)))
    (write-pddl-file (cadar problem-def)
		     (car (find-argument problem-def :domain))
		     instances new-state new-goals
		     (concatenate 'string probsets-dir problem-file)
		     (find-argument problem-def :metric))))

;; removes from literals those predicates that are not part of the agent predicates or such that their types do not
;; match with those of the predicate definition
(defun remove-invalid-predicates (literals predicates types objects)
  (remove-if-not #'(lambda (literal)
		     (let ((predicate (assoc (car literal) predicates)))
		       (or (eq (car literal) '=)
			   (and predicate
				(compatible-types-p (cdr literal) (cdr predicate) types objects)))))
		 literals))

(defun compatible-types-p (args-list predicate-params types instances)
  (do* ((args args-list (cdr args))
	(params predicate-params (cdddr params))
	(type nil)
	(compatible-p t))
      ((or (null args) (not compatible-p))
       compatible-p)
    (setq type (car (find-if #'(lambda (instance-def)
				 (member (car args) (cdr instance-def)))
			     instances)))
    (setq compatible-p (or (eq type (caddr params)) (member (caddr params) (super-types type types))))))

;; It assumes *agents* contains a list of agent structures
;; I do not deal with constants yet, though there is no domain in the IPC that we deal with that has constants
(defun obfuscate-domain (internal-predicates internal-types agent-types domain-def domain-dir)
  (let* ((domain-name (car (find-argument domain-def 'domain)))
	 types constants actions agent-name
	 new-domain-def new-domain-name new-predicates new-functions new-actions
	 super-types other-agents-types)
    (setf *original-actions* (mapcar #'cadr (give-me-all-actions domain-def)))
    (dolist (agent *agents*)
      (setf *anonymize-alist* nil)
      (setq agent-name (agent-name agent))
      (setq new-domain-def domain-def)
      ;;      (sublis (agent-anonymize-list agent) domain-def))
      (setq types (sublis (agent-anonymize-list agent) (process-types (find-argument new-domain-def :types))))
      ;; list of super-types of the agent type
      (setq super-types (cons (agent-type agent) (super-types (agent-type agent) types)))
      (setq other-agents-types (set-difference (super-types-of-set agent-types types) super-types))
;;       (format t "~%Super-types: ~a~%Other-agent-types: ~a~%" super-types other-agents-types)
      (setf *static-predicates* nil)
      (setq new-predicates (obfuscate-predicate-defs (find-argument new-domain-def :predicates)
						     agent types super-types internal-predicates internal-types
						     other-agents-types))
      (setq new-functions (obfuscate-predicate-defs (find-argument new-domain-def :functions)
						    agent types super-types internal-predicates internal-types other-agents-types))
      (setq constants (sublis (append *anonymize-alist* (agent-anonymize-list agent))
			      (cleanup-params (find-argument new-domain-def :constants))))
      (setq actions (give-me-all-actions new-domain-def))
      (setq new-domain-name (format nil "obfuscated-~(~a~)-~(~a~).pddl"
				    (car (find-argument domain-def 'domain)) agent-name))
      (setf *grounded-public-predicates-joint-actions* nil)
      (setq new-actions (mapcan #'(lambda (action)
				    ;; if action belongs to other agents' types only (not a joint action) or
				    ;; it contains an agent super-type (so that we can deal with joint-actions)
				    (if (or (intersection (nth 3 action) super-types)
					    (not (intersection (nth 3 action) other-agents-types)))
					(obfuscate-action action agent super-types types internal-types
							  internal-predicates other-agents-types)))
				actions))
      ;; we need to add as new predicates the ones that appear in joint-actions that refer to the other agents
      (setq new-predicates (typed-union new-predicates *grounded-public-predicates-joint-actions* types))
      ;; (if *trace-ma-sayphi* (format t "~%Agent: ~a~%New-predicates~a" agent-name new-predicates))
      ;; (if *trace-ma-sayphi* (report-undefined-predicates new-predicates *predicates-in-problem*))
      (setf (agent-anonymize-list agent) (union (agent-anonymize-list agent) *anonymize-alist* :test #'equal))
      (setf (agent-reverse-anonymize-list agent)
	    (mapcar #'(lambda (pair) (cons (cdr pair) (car pair)))
		    (agent-anonymize-list agent)))
      (write-domain-pddl-file domain-name (find-argument domain-def :requirements) (flatten-types types)
			      new-predicates new-functions new-actions
			      (concatenate 'string domain-dir new-domain-name)
			      constants)
      (setf (agent-static-predicates agent) *static-predicates*)
      (setf (agent-predicates agent) new-predicates)
      (setf (agent-domain-file agent) new-domain-name))))

;; Computes the union of the two lists of predicates, generalizing predicate definitions that subsume others.
;; For instance (at ?t - truck ?p - place) and (at ?t - airplane ?p - place) would be generalized to
;; (at ?vehicle - vehicle ?p - place)
(defun typed-union (predicates new-predicates types)
  (let ((result predicates) clean-predicate)
    (dolist (predicate new-predicates)
      (let ((previous (assoc (car predicate) result)))
	(setq clean-predicate (cons (car predicate) (cleanup-params (cdr predicate))))
	(cond (previous
	       (do* ((args (cleanup-params (cdr previous)) (cdddr args))
		     (args2 (cdr clean-predicate) (cdddr args2))
		     (new-args nil)
		     (type (caddr args) (caddr args))
		     (type2 (caddr args2) (caddr args2))
		     (common-supertype nil)
		     (differentp nil))
		   ((or (null args) (null args2) differentp)
		    (cond (differentp (push clean-predicate result))
			  (t (setq result (remove previous result :test #'equal)) ;; it might have to be :key #'car :test #'eq
			     (push (cons (car clean-predicate) (reverse new-args)) result))))
		 (setq common-supertype (find-common-super-type type type2 types))
		 (cond ((or (not common-supertype) (eq common-supertype 'object))
			(setq differentp t))
		       (t (push (intern (format nil "~:@(?~a~)" common-supertype)) new-args)
			  (push '- new-args)
			  (push common-supertype new-args)))))
	      (t (push clean-predicate result)))))
    result))

;; Given two types and a set of types, it returns the closest super-type of both
(defun find-common-super-type (type1 type2 types)
  (do* ((super-types1 (cons type1 (super-types type1 types)))
	(super-types2 (cons type2 (super-types type2 types)))
	(stypes1 super-types1 (cdr stypes1))
	(stypes2 super-types2 (cdr stypes2))
	(common-supertype nil))
       ((or common-supertype (null stypes1) (null stypes2))
	common-supertype)
    (setq common-supertype (car (or (member (car stypes1) stypes2)
				    (member (car stypes2) stypes1))))))

;; Given two types, where I assume one is a subtype of the other and a set of types, it returns the most specific type
(defun find-common-subtype (type1 type2 types)
  (cond ((eq type1 type2) type1)
	((member type2 (super-types type1 types)) type1)
	((member type1 (super-types type2 types)) type2)
	(t nil)))

(defun obfuscate-predicate-defs (predicate-defs agent types super-types internal-predicates internal-types other-agents-types)
  (mapcan #'(lambda (predicate-def)
	      ;; they will be removed from that list after processing actions
	      (let ((result (obfuscate-predicate-def predicate-def agent types super-types internal-predicates
						     internal-types other-agents-types)))
		(pushnew (car predicate-def) *static-predicates*)
		(if result
		    (pushnew (caar result) *static-predicates*))
		result))
	  predicate-defs))

;; It returns an obfuscated predicate definition
;; Now, it can handle joint predicates and returns the cross product of all instantiations of agent params values
(defun obfuscate-predicate-def (predicate-def agent types super-types internal-predicates internal-types other-agents-types)
  (do* ((cleaned-args (cleanup-params (cdr predicate-def)))
	(predicate-def-list cleaned-args (cdddr predicate-def-list))
	(agent-name (agent-name agent))
	(agents-inside nil)
;; 	(all-super-types (append super-types other-agents-types))
	(new-predicate-defs nil)
	(new-predicate-def nil)
	(cross-product nil)
	(new-cross-product nil))
       ((null predicate-def-list)
;; 	(format t "~%Agents inside: ~a~%New predicate def: ~a" agents-inside new-predicate-def)
	(cond ((member (car predicate-def) internal-predicates)
	       ;; I assume internal types will only appear in internal-predicates. Thus, I do not check
	       (list (cons (anonymize-name (car predicate-def) (list agent-name) t)
			   (nreverse new-predicate-def))))
	      ((> (length agents-inside) 1)
	       ;; only if there are joint-actions there will be joint predicates
	       (dolist (an-agent *agents*)
		 (if (compatible-type-p (cdar agents-inside) an-agent types)
		     (push (list (agent-name an-agent)) cross-product)))
	       (dolist (agent-type (cdr agents-inside))
		 (setq new-cross-product nil)
		 (dolist (an-agent *agents*)
		   (if (compatible-type-p (cdr agent-type) an-agent types)
		       (dolist (agents-list cross-product)
			 (push (reverse (cons (agent-name an-agent) agents-list))
			       new-cross-product))))
		 (setq cross-product (reverse new-cross-product)))
;; 	       (format t "~%Cross product: ~a" cross-product)
	       (dolist (agents-set cross-product)
 		 (if (member agent-name agents-set)
		     (pushnew (cons (rename (car predicate-def) agents-set t)
				    (reverse new-predicate-def))
			      new-predicate-defs :test #'equal)))
	       new-predicate-defs)
	      (agents-inside
	       (if (member (cdar agents-inside) super-types)
		   (list (cons (rename (car predicate-def) (list agent-name) t)
			       (reverse new-predicate-def)))))
	      (t (list (cons (car predicate-def) cleaned-args)))))
    (cond ((member (caddr predicate-def-list) super-types)
	   (push (cons (car predicate-def-list) (caddr predicate-def-list))
		 agents-inside))
	  (t (push (car predicate-def-list) new-predicate-def)
	     (push (cadr predicate-def-list) new-predicate-def)
	     (push (if (member (caddr predicate-def-list) internal-types)
		       (anonymize-name (caddr predicate-def-list) (list agent-name) t)
		       (caddr predicate-def-list))
		   new-predicate-def)))))

;; returns a list of actions, given that joint-actions can generate more than one action (one for each appearance of a
;; super-type of the agent-type in the parameters)
;; It can now handle joint actions
(defun obfuscate-action (action agent super-types types internal-types internal-predicates other-agents-types)
  (let* ((parameters (nth 3 action))
	 (agent-inside-p (intersection super-types parameters))
	 (internal-type-inside-p (intersection parameters internal-types)))
    (setf *agent-var* nil)
;;     (format t "~%Static predicates after effects ~a:~%  ~a" (nth 7 action) *static-predicates*)
    (cond ((or agent-inside-p internal-type-inside-p)
	   (obfuscate-private-action action agent super-types types parameters
				     internal-predicates other-agents-types))
	  (t (detect-dynamic-predicates (nth 7 action))
	     (detect-dynamic-predicates (sublis *anonymize-alist* (nth 7 action)))
	     (list (sublis *anonymize-alist* action))))))

;; it works as a side effect by removing dynamic predicates from the list *static-predicates* if they belong to the
;; effects list of an action
(defun detect-dynamic-predicates (exp)
  (case (car exp)
    ((and or) (dolist (subexp (cdr exp)) (detect-dynamic-predicates subexp)))
    (not (detect-dynamic-predicates (cadr exp)))
    ((increase assign <= >= + * - / < > when)
     (detect-dynamic-predicates (cadr exp))
     (if (listp (caddr exp)) (detect-dynamic-predicates (caddr exp))))
    ((forall exists) (detect-dynamic-predicates (caddr exp)))
    (otherwise (setf *static-predicates* (remove (car exp) *static-predicates*)))))

(defun obfuscate-private-action (action agent super-types types parameters internal-predicates other-agents-types)
  (setf *all-params* parameters)
  (detect-forall-exists-params (nth 7 action))
  (let* ((action-name (nth 1 action))
	 (args (get-agent-types *all-params* super-types types agent other-agents-types))
;;	 (joint-action-p (> (length args) 1))
;;	 (agent-vars (mapcar #'car args))
	 new-name new-params agents-params new-actions new-alist agents-vars new-preconds new-effects
	 stored-action-def)
    (setf *private-action-p* nil)
    (dolist (params-instantiation args)
      (setq new-alist (copy-list *anonymize-alist*))
      (setq agents-vars nil agents-params nil new-params nil stored-action-def nil)
      (dolist (vars-defs params-instantiation)
	(cond ((listp (cdr vars-defs))
	       (push vars-defs stored-action-def)
	       (push vars-defs new-params))
	      (t (push (cdr vars-defs) agents-params)
		 (push (car vars-defs) agents-vars)
		 (push (cdr vars-defs) stored-action-def)
		 (push vars-defs new-alist))))
      (setq new-params (reverse new-params))
      (setq agents-params (reverse agents-params))
      ;; I would have to rename it only if all predicates are public
      (setq new-preconds (remove-duplicates (remove-agent-var (nth 5 action) (agent-name agent) agents-vars agents-params
							      new-params new-alist internal-predicates)
					    :test #'equal))
      ;; they might be nil if joint action, with an equality and some combination of agents not allowed by the equality
      (when new-preconds
	(setq new-effects (remove-duplicates (remove-agent-var (nth 7 action) (agent-name agent) agents-vars agents-params
							       new-params new-alist internal-predicates)
					     :test #'equal))
	(setq new-name (if *private-action-p*
			   (anonymize-name action-name agents-params t)
			   (rename action-name agents-params t)))
	(push (cons new-name (reverse (sublis *anonymize-alist* stored-action-def)))
	      (agent-positions-in-actions agent))
	(push (list :action new-name
		    :parameters (sublis *anonymize-alist* (reduce #'append new-params))
		    :precondition new-preconds
		    :effect new-effects)
	      new-actions)))
    (detect-dynamic-predicates (nth 7 action))
    (detect-dynamic-predicates new-effects)
    (reverse new-actions)))


;; It returns a list of params instantiations: each params instantiation is a list of P,
;; where P ::= (agent-var . agent-name) | (non-agent-var - type)
(defun get-agent-types (params super-types types agent other-agents-types)
  (do* ((args (cleanup-params params) (cdddr args))
	(i 0 (1+ i))
	(type (caddr args) (caddr args))
	(agent-seen 0)
	(agent-name (agent-name agent))
	(cross-product nil)
	(new-cross-product nil))
      ((null args)
       (remove-if-not #'(lambda (new-params) (member agent-name new-params :key #'cdr)) ;; for single-agent actions
		      cross-product))
    ;; it should enter here at least once, given that we know it is a private action
    (cond ((member type super-types)
	   (setq new-cross-product nil)
	   (if (compatible-type-p type agent types)
	       (setf *agent-var* (car args)))
	   (if (> agent-seen 0) ;; #times it has already seen an agent var before
	       (dolist (an-agent *agents*)
		 (if (compatible-type-p type an-agent types)
		     (dolist (agents-list cross-product)
		       (push (reverse (cons (cons (car args) (agent-name an-agent)) (reverse agents-list)))
			     new-cross-product))))
	       (if cross-product
		   (dolist (params cross-product)
		     (dolist (an-agent *agents*)
		       (if (compatible-type-p type an-agent types)
			   (push (reverse (cons (cons (car args) (agent-name an-agent)) (reverse params)))
				 new-cross-product))))
		   (dolist (an-agent *agents*)
		     (if (compatible-type-p type an-agent types)
			 (push (list (cons (car args) (agent-name an-agent)))
			       new-cross-product)))))
	   (incf agent-seen)
	   (setq cross-product (reverse new-cross-product)))
	  ((member type other-agents-types)
	   (setq new-cross-product nil)
	   (if cross-product
	       (dolist (params cross-product)
		 (dolist (an-agent *agents*)
		   (if (compatible-type-p type an-agent types)
		       (push (reverse (cons (cons (car args) (agent-name an-agent)) (reverse params)))
			     new-cross-product))))
	       (dolist (an-agent *agents*)
		 (if (compatible-type-p type an-agent types)
		     (push (list (cons (car args) (agent-name an-agent)))
			   new-cross-product))))
	   (setq cross-product (reverse new-cross-product)))
	  (t (cond (cross-product
		    (setq new-cross-product nil)
		    (dolist (agents-list cross-product)
		      (push (reverse (cons (list (car args) '- type) (reverse agents-list)))
			    new-cross-product))
		    (setq cross-product new-cross-product))
		   (t (setq cross-product (list (list (list (car args) '- type))))))))))

(defun compatible-type-p (type agent types)
  (let ((agent-type (agent-type agent)))
    (or (eq type agent-type)
	(member type (super-types agent-type types)))))

(defun remove-agent-var (exp agent-name agents-vars agents-params new-params new-alist internal-predicates)
  (case (car exp)
    ((and or)
     (let ((result (remove-agent-var (cdr exp) agent-name agents-vars agents-params new-params new-alist internal-predicates)))
       (if result (cons (car exp) result))))
    (not (let ((result (remove-agent-var (cadr exp) agent-name agents-vars agents-params new-params new-alist internal-predicates)))
	   (if result (cons (car exp) (list result)))))
    ((increase assign <= >= + * - / < > when)
     (let ((result1 (remove-agent-var (cadr exp) agent-name agents-vars agents-params new-params new-alist internal-predicates))
	   (result2 nil))
       (when result1
	 (setq result2 (if (numberp (caddr exp))
			   (caddr exp)
			   (remove-agent-var (caddr exp) agent-name agents-vars agents-params new-params
					     new-alist internal-predicates)))
	 (if result2
	     (list (car exp) result1 result2)))))
    ((forall exists)
     (let ((result1 (remove-agent-var (caddr exp) agent-name agents-vars agents-params new-params new-alist internal-predicates)))
       (if result1
	   (list (car exp) (cadr exp) result1))))
    (otherwise ;; I hope list of literals or individual literal
     (cond ((listp (car exp))
	    (obfuscate-preconds-effects exp agent-name agents-vars agents-params
					new-params new-alist internal-predicates))
	   (t (obfuscate-precond-effect exp agent-name agents-vars agents-params new-params new-alist internal-predicates))))))

(defun obfuscate-preconds-effects (exp agent-name agents-vars agents-params new-params new-alist internal-predicates)
  (do* ((literals exp (cdr literals))
	(result nil)
	(final-list nil)
	(null-precond-p nil))
       ((or null-precond-p (null literals))
	(if (not null-precond-p)
	    (reverse final-list)))
    (setq result (remove-agent-var (car literals) agent-name agents-vars agents-params
				   new-params new-alist internal-predicates))
    (cond ((and (eq (car result) '=)
		(or (member (cadr result) agents-params)
		    (member (caddr result) agents-params)))
	   (if (not (eq (cadr result) (caddr result)))
	       (setq null-precond-p t)))
	  ((and (eq (car result) 'not)
		(eq (caadr result) '=)
		(or (member (cadadr result) agents-params)
		    (member (caddr (cadr result)) agents-params)))
	   (if (eq (cadadr result) (caddr (cadr result)))
	       (setq null-precond-p t)))
	  (t (push result final-list)))))
  
(defun obfuscate-precond-effect (exp agent-name agents-vars agents-params new-params new-alist internal-predicates)
  (let* ((equalityp (eq (car exp) '=))
	 (args (cdr exp))
	 (substituted-args (sublis new-alist args))
	 (agents-in-exp (remove-if-not #'(lambda (arg) (member arg agents-params)) substituted-args))
	 (new-name nil))
    (case (length agents-in-exp)
      (0 (cond ((member (car exp) internal-predicates)
		(setf *private-action-p* t)
		(cons (anonymize-name (car exp) (list agent-name) t) args))
	       (t exp)))
      (1 (setq new-name (cond ((member (car exp) internal-predicates)
			       (setf *private-action-p* t)
			       (anonymize-name (car exp) agents-in-exp t))
			      (equalityp '=)
			      (t (rename (car exp) agents-in-exp t))))
	 (if (and (not equalityp)
		  (not (eq (car agents-in-exp) agent-name)))
	     (pushnew (cons new-name
			    (reduce #'append (remove-if #'(lambda (arg-def)
							    (or (member (car arg-def) agents-params)
								(not (member (car arg-def) substituted-args))))
							new-params)))
		      *grounded-public-predicates-joint-actions* :test #'equal))
;; 	 (if (eq (car exp) 'tiene)
;; 	     (format t "~2%Agent: ~a~%Exp: ~a~%grounded: ~a~%substituted-args: ~a~%agent-params: ~a~%new-params: ~a"
;; 		     agent-name exp (car *grounded-public-predicates-joint-actions*) substituted-args agents-params new-params))
	 (cons new-name (if equalityp args (remove-if #'(lambda (arg) (member arg agents-vars)) args))))
      (otherwise (if (member (car exp) internal-predicates)
		     (format t "~%~a has been defined as internal, but it appears in a joint action" (car exp)))
		 (setq new-name (if equalityp '= (rename (car exp) agents-in-exp t)))
		 (if (not equalityp)
		     (pushnew (cons new-name
				    (reduce #'append (remove-if #'(lambda (arg-def)
								    (or (member (car arg-def) agents-params)
									(not (member (car arg-def) substituted-args))))
								new-params)))
			   *grounded-public-predicates-joint-actions* :test #'equal))
		 (cons new-name
		       (if equalityp
			   substituted-args
			   (remove-if #'(lambda (arg) (member arg agents-params)) substituted-args)))))))

;; it works as a side effect by adding params of foralls and exists into *all-params* that initially includes the action
;; parameters
;; Requirement: two foralls/exists in the same action cannot use the same objects in their params
(defun detect-forall-exists-params (exp)
  (case (car exp)
    ((and or) (dolist (subexp (cdr exp)) (detect-forall-exists-params subexp)))
    (not (detect-forall-exists-params (cadr exp)))
    ((increase assign <= >= + * - / < > when)
     (detect-forall-exists-params (cadr exp))
     (if (listp (caddr exp)) (detect-forall-exists-params (caddr exp))))
    ((forall exists)
     (do ((args (cleanup-params (cadr exp)) (cdddr args)))
	 ((null args) *all-params*)
       (push (caddr args) *all-params*)
       (push (cadr args) *all-params*)
       (push (car args) *all-params*)))
    (otherwise nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Merging domain and problem definitions of all agents
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; It computes the merging of all domains and problems of all agents and saves the merged domain and problem files
(defun obfuscate-merged-domain-problem (domain-dir probsets-dir
					&key (domain-file *merged-domain*) (problem-file *merged-problem*) (agents *agents*))
  (let ((domain-def (cdr (read-all-file (concatenate 'string domain-dir (agent-domain-file (car agents))))))
	(problem-def (cdr (read-all-file (concatenate 'string probsets-dir (agent-problem-file (car agents)))))))
    (dolist (agent (cdr agents))
      (setq domain-def (merge-domain-defs domain-def
					  (cdr (read-all-file (concatenate 'string domain-dir
									   (agent-domain-file agent))))))
      (setq problem-def (merge-problem-defs problem-def
					    (cdr (read-all-file (concatenate 'string probsets-dir
									     (agent-problem-file agent)))))))
    (write-domain domain-def domain-dir domain-file)
    (write-problem problem-def probsets-dir problem-file)))

;; I can compute this more efficiently (by keeping the processed elements from the previous iteration,
;; but I am not sure it is worth unless we have a huge number of agents
(defun merge-domain-defs (def1 def2)
  (let* ((types (merge-types (process-types (find-argument def1 :types))
			     (process-types (find-argument def2 :types))))
	 (functions (typed-union (find-argument def1 :functions) (find-argument def2 :functions) types))
	 (constants (flatten-instances (merge-instances (process-instances (find-argument def1 :constants))
							(process-instances (find-argument def2 :constants))))))
    (append (list (car def1))
	    (list (cons :requirements (find-argument def1 :requirements)))
	    (list (cons :types (flatten-types types)))
	    (list (cons :predicates (typed-union (find-argument def1 :predicates) (find-argument def2 :predicates) types)))
	    (if functions (list (cons :functions functions)))
	    (if constants (list (cons :constants constants)))
	    (union (give-me-all-actions def1)
		   (give-me-all-actions def2)
		   :test 'equal))))

(defun merge-problem-defs (def1 def2)
  (list (car def1)
	(cons :domain (find-argument def1 :domain))
	(cons :objects (flatten-instances (merge-instances (process-instances (find-argument def1 :objects))
							   (process-instances (find-argument def2 :objects)))))
	(cons :init (union (find-argument def1 :init) (find-argument def2 :init) :test #'equal))
	(list :goal (cons 'and (union (give-me-all-goals def1) (give-me-all-goals def2) :test #'equal)))
	(cons :metric (find-argument def1 :metric))))

(defun write-domain (domain-def domain-dir domain-file)
  (write-domain-pddl-file (cadar domain-def)
			  (find-argument domain-def :requirements)
			  (find-argument domain-def :types)
			  (find-argument domain-def :predicates)
			  (find-argument domain-def :functions)
			  (give-me-all-actions domain-def)
			  (concatenate 'string domain-dir domain-file)
			  (find-argument domain-def :constants)))

(defun write-problem (problem-def probsets-dir problem-file)
  (write-pddl-file (cadar problem-def)
		   (car (find-argument problem-def :domain))
		   (find-argument problem-def :objects)
		   (find-argument problem-def :init)
		   (give-me-all-goals problem-def)
		   (concatenate 'string probsets-dir problem-file)
		   (find-argument problem-def :metric)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Translation from MA-PDDL to PDDL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; init-agents-types and init-internal-predicates allow to input the whole process initial lists of agents and
;; internal-predicates in cases we want to provide them directly as input and not expecting they are in a MA-PDDL syntax.
;; Inputs MA-PDDL domain and problem files and writes as output equivalent PDDL files+agent+privacy information
;; (ma-pddl-to-pddl "domain.pddl" "/Users/dborrajo/Desktop/CoDMAP/logistics00-cen/" "probLOGISTICS-4-0.pddl" "/Users/dborrajo/Desktop/CoDMAP/logistics00-cen/")
(defun ma-pddl-to-pddl (domain-file domain-dir problem-file &optional probsets-dir new-domain-file new-problem-file
							      init-agents-types init-internal-predicates)
  (write-message "Compiling MA-PDDL into PDDL" nil)
  (setf *predicates-in-action* nil)
  (if (not probsets-dir)
      (setq probsets-dir (concatenate 'string domain-dir "probsets/")))
  (if (not new-domain-file)
      (setq new-domain-file (concatenate 'string "codmap-" (pathname-name domain-file) "." (pathname-type domain-file))))
  (if (not new-problem-file)
      (setq new-problem-file (concatenate 'string "codmap-" (pathname-name problem-file) "."
					  (pathname-type problem-file))))
  (let* ((domain-def (cdr (read-all-file (concatenate 'string domain-dir domain-file))))
	 (problem-def (cdr (read-all-file (concatenate 'string probsets-dir problem-file))))
	 (types (process-types (find-argument domain-def :types)))
	 (leaf-types (leaf-types types))
	 (non-agent-types types)
	 (agent-types init-agents-types)
	 (internal-predicates init-internal-predicates)
	 (actions (give-me-all-actions domain-def))
	 agent-def new-actions new-predicates new-functions new-objects
	 parameters mixed-parameters alist privatep aux-new-predicates new-name predicates-args)
    (dolist (action-def actions)
      (cond ((setq agent-def (member :agent action-def))
	     (setq parameters (cadr (member :parameters action-def)))
	     (push (append (subseq action-def 0 2)
			   (list :parameters (append (subseq agent-def 1 (position :parameters agent-def)) parameters))
			   (subseq action-def (position :precondition action-def)))
		   new-actions)
	     (pushnew (nth 3 agent-def) agent-types)
	     (dolist (type (sub-types (list (nth 3 agent-def)) types))
	       (pushnew type agent-types)))
	    ;; I do not think they will allow actions without agents in MA-PDDL :-}. just in case
	    (t (push action-def new-actions))))
    (setq agent-types (augment-agent-types agent-types types))
    (setq non-agent-types (set-difference (sub-types '(object) types) agent-types))
    (dolist (predicate (find-argument domain-def :predicates))
      (setq privatep (and (listp predicate) (eq (car predicate) :private)))
      (dolist (predicate-def (if privatep (nthcdr 4 predicate) (list predicate)))
	;; I obviate the information of whose agent types have that predicate as private. I assume it is private to all agents
	(if privatep (pushnew (car predicate-def) internal-predicates))
	(setq mixed-parameters (compute-mixed-parameters agent-types (cdr predicate-def) types non-agent-types))
	(cond (mixed-parameters
	       (setq aux-new-predicates nil)
	       (if privatep (pop internal-predicates))
	       ;; I do not deal now with predicates with two or more mixed-parameters
	       (dolist (mixed-parameter mixed-parameters)
		 (pushnew (cons (car predicate-def) (cadr mixed-parameter)) predicates-args :test #'equal)
		 (dolist (leaf-type (intersection leaf-types (cddr mixed-parameter)))
		   (setq new-name (intern (format nil "~:@(~a-~a~)" (car predicate-def) leaf-type)))
		   (pushnew (sublis (list (cons (car predicate-def) new-name) (cons (car mixed-parameter) leaf-type))
				    predicate-def)
			    new-predicates :test #'equal)
		   (if privatep (pushnew new-name internal-predicates :test #'equal))
		   (pushnew (cons leaf-type new-name) aux-new-predicates :test #'equal)))
	       (pushnew (cons (car predicate-def) aux-new-predicates) alist :test #'equal))
	      (t (pushnew predicate-def new-predicates :test #'equal)))))
    (dolist (function (find-argument domain-def :functions))
      (when (listp function)
	(setq privatep (and (listp function) (eq (car function) :private)))
	(dolist (function-def (if privatep (nthcdr 4 function) (list function)))
	  ;; I obviate the information of whose agent types have that function as private. I assume it is private to all agents
	  (if privatep (pushnew (car function-def) internal-predicates))
	  (setq mixed-parameters (compute-mixed-parameters agent-types (cdr function-def) types non-agent-types))
	  (cond (mixed-parameters
		 (setq aux-new-predicates nil)
		 (if privatep (pop internal-predicates))
		 ;; I do not deal now with functions with two or more mixed-parameters
		 (dolist (mixed-parameter mixed-parameters)
		   (pushnew (cons (car function-def) (cadr mixed-parameter)) predicates-args :test #'equal)
		   (dolist (leaf-type (intersection leaf-types (cddr mixed-parameter)))
		     (setq new-name (intern (format nil "~:@(~a-~a~)" (car function-def) leaf-type)))
		     (pushnew (sublis (list (cons (car function-def) new-name) (cons (car mixed-parameter) leaf-type))
				      function-def)
			      new-functions :test #'equal)
		     (if privatep (pushnew new-name internal-predicates :test #'equal))
		     (pushnew (cons leaf-type new-name) aux-new-predicates :test #'equal)))
		 (pushnew (cons (car function-def) aux-new-predicates) alist :test #'equal))
		(t (pushnew function-def new-functions :test #'equal))))))
    (setq actions new-actions)
    (setq new-actions nil)
    (setf *ma-pddl-alist* nil)
    (dolist (action-def actions)
      (dolist (new-action (update-action action-def alist agent-types non-agent-types leaf-types types predicates-args))
	(pushnew new-action new-actions :test #'equal)))
    (if *trace-ma-sayphi*
	(format t "~2%Discovered in MA-PDDL files:~%  Agent types: ~a~% Internal predicates: ~a" agent-types internal-predicates))
    (write-domain-pddl-file (cadar domain-def)
			    (remove-if #'(lambda (req) (member req '(:multi-agent :unfactored-privacy)))
				       (find-argument domain-def :requirements))
			    (find-argument domain-def :types)
			    (nreverse new-predicates) (nreverse new-functions) new-actions
			    (concatenate 'string domain-dir new-domain-file)
			    (find-argument domain-def :constants))
    (do* ((objects (find-argument problem-def :objects) (cdr objects))
	  (position 0))
	 ((null objects))
      (cond ((and (listp (car objects)) (eq (caar objects) :private))
	     (setq new-objects (append new-objects (cddar objects))))
	    (t (setq position (position '- objects))
	       (setq new-objects (append new-objects (subseq objects 0 (+ 2 position))))
	       (setq objects (subseq objects (+ 1 position))))))
    (setq new-objects (cleanup-params new-objects))
    (write-pddl-file (cadar problem-def) (car (find-argument problem-def :domain))
		     new-objects (update-exp (find-argument problem-def :init) alist new-objects)
		     (update-exp (give-me-all-goals problem-def) alist new-objects)
		     (concatenate 'string probsets-dir new-problem-file)
		     (find-argument problem-def :metric))
    (list agent-types internal-predicates))) 

;; (defun ma-pddl-to-pddl (domain-file domain-dir problem-file &optional probsets-dir new-domain-file new-problem-file
;; 							      init-agents-types init-internal-predicates)
;;   (write-message "Compiling MA-PDDL into PDDL" nil)
;;   (setf *predicates-in-action* nil)
;;   (if (not probsets-dir)
;;       (setq probsets-dir (concatenate 'string domain-dir "probsets/")))
;;   (if (not new-domain-file)
;;       (setq new-domain-file (concatenate 'string "codmap-" (pathname-name domain-file) "." (pathname-type domain-file))))
;;   (if (not new-problem-file)
;;       (setq new-problem-file (concatenate 'string "codmap-" (pathname-name problem-file) "."
;; 					  (pathname-type problem-file))))
;;   (let* ((domain-def (cdr (read-all-file (concatenate 'string domain-dir domain-file))))
;; 	 (problem-def (cdr (read-all-file (concatenate 'string probsets-dir problem-file))))
;; 	 (types (process-types (find-argument domain-def :types)))
;; 	 (leaf-types (leaf-types types))
;; 	 (non-agent-types types)
;; 	 (agent-types init-agents-types)
;; 	 (internal-predicates init-internal-predicates)
;; 	 (actions (give-me-all-actions domain-def))
;; 	 leaf-agent-types agent-def new-actions new-predicates new-functions new-objects
;; 	 parameters mixed-parameters alist privatep aux-new-predicates new-name predicates-args)
;;     (dolist (action-def actions)
;;       (cond ((setq agent-def (member :agent action-def))
;; 	     (setq parameters (cadr (member :parameters action-def)))
;; 	     (push (append (subseq action-def 0 2)
;; 			   (list :parameters (append (subseq agent-def 1 (position :parameters agent-def)) parameters))
;; 			   (subseq action-def (position :precondition action-def)))
;; 		   new-actions)
;; 	     (pushnew (nth 3 agent-def) agent-types)
;; 	     (dolist (type (sub-types (list (nth 3 agent-def)) types))
;; 	       (pushnew type agent-types)))
;; 	    ;; I do not think they will allow actions without agents in MA-PDDL :-}. just in case
;; 	    (t (push action-def new-actions))))
;;     (setq leaf-agent-types agent-types)
;;     (setq agent-types (augment-agent-types agent-types types))
;;     (setq non-agent-types (set-difference (sub-types '(object) types) agent-types))
;;     (dolist (predicate (find-argument domain-def :predicates))
;;       (setq privatep (and (listp predicate) (eq (car predicate) :private)))
;;       (dolist (predicate-def (if privatep (nthcdr 4 predicate) (list predicate)))
;; 	;; I obviate the information of whose agent types have that predicate as private. I assume it is private to all agents
;; 	(if privatep (pushnew (car predicate-def) internal-predicates))
;; 	(setq mixed-parameters (compute-mixed-parameters agent-types (cdr predicate-def) types non-agent-types))
;; 	(cond (mixed-parameters
;; 	       (setq aux-new-predicates nil)
;; 	       (if privatep (pop internal-predicates))
;; 	       ;; I do not deal now with predicates with two or more mixed-parameters
;; 	       (dolist (mixed-parameter mixed-parameters)
;; 		 (pushnew (cons (car predicate-def) (cadr mixed-parameter)) predicates-args :test #'equal)
;; 		 (dolist (leaf-type (intersection leaf-types (cddr mixed-parameter)))
;; 		   (setq new-name (intern (format nil "~:@(~a-~a~)" (car predicate-def) leaf-type)))
;; 		   (pushnew (sublis (list (cons (car predicate-def) new-name) (cons (car mixed-parameter) leaf-type)) predicate-def)
;; 			    new-predicates :test #'equal)
;; 		   (if privatep (pushnew new-name internal-predicates :test #'equal))
;; 		   (pushnew (cons leaf-type new-name) aux-new-predicates :test #'equal)))
;; 	       (pushnew (cons (car predicate-def) aux-new-predicates) alist :test #'equal))
;; 	      (t (pushnew predicate-def new-predicates :test #'equal)))))
;;     (dolist (function (find-argument domain-def :functions))
;;       (setq privatep (and (listp function) (eq (car function) :private)))
;;       (dolist (function-def (if privatep (nthcdr 4 function) (list function)))
;; 	;; I obviate the information of whose agent types have that function as private. I assume it is private to all agents
;; 	(if privatep (pushnew (car function-def) internal-predicates))
;; 	(setq mixed-parameters (compute-mixed-parameters agent-types (cdr function-def) types non-agent-types))
;; 	(cond (mixed-parameters
;; 	       (setq aux-new-predicates nil)
;; 	       (if privatep (pop internal-predicates))
;; 	       ;; I do not deal now with functions with two or more mixed-parameters
;; 	       (dolist (mixed-parameter mixed-parameters)
;; 		 (pushnew (cons (car function-def) (cadr mixed-parameter)) predicates-args :test #'equal)
;; 		 (dolist (leaf-type (intersection leaf-types (cddr mixed-parameter)))
;; 		   (setq new-name (intern (format nil "~:@(~a-~a~)" (car function-def) leaf-type)))
;; 		   (pushnew (sublis (list (cons (car function-def) new-name) (cons (car mixed-parameter) leaf-type)) function-def)
;; 			 new-functions :test #'equal)
;; 		   (if privatep (pushnew new-name internal-predicates :test #'equal))
;; 		   (pushnew (cons leaf-type new-name) aux-new-predicates :test #'equal)))
;; 	       (pushnew (cons (car function-def) aux-new-predicates) alist :test #'equal))
;; 	      (t (pushnew function-def new-functions :test #'equal)))))
;;     (setq actions new-actions)
;;     (setq new-actions nil)
;;     (setf *ma-pddl-alist* nil)
;;     (dolist (action-def actions)
;;       (dolist (new-action (update-action action-def alist agent-types non-agent-types leaf-types types predicates-args))
;; 	(pushnew new-action new-actions :test #'equal)))
;;     (if *trace-ma-sayphi*
;; 	(format t "~2%Discovered in MA-PDDL files:~%  Agent types: ~a~%  Internal predicates: ~a" agent-types internal-predicates))
;;     (write-domain-pddl-file (cadar domain-def)
;; 			    (remove-if #'(lambda (req) (member req '(:multi-agent :unfactored-privacy)))
;; 				       (find-argument domain-def :requirements))
;; 			    (find-argument domain-def :types)
;; 			    (nreverse new-predicates) (nreverse new-functions) new-actions
;; 			    (concatenate 'string domain-dir new-domain-file)
;; 			    (find-argument domain-def :constants))
;;     (do* ((objects (find-argument problem-def :objects) (cdr objects))
;; 	  (position 0))
;; 	 ((null objects))
;;       (cond ((and (listp (car objects)) (eq (caar objects) :private))
;; 	     (setq new-objects (append new-objects (cddar objects))))
;; 	    (t (setq position (position '- objects))
;; 	       (setq new-objects (append new-objects (subseq objects 0 (+ 2 position))))
;; 	       (setq objects (subseq objects (+ 1 position))))))
;;     (setq new-objects (cleanup-params new-objects))
;;     (write-pddl-file (cadar problem-def) (car (find-argument problem-def :domain))
;; 		     new-objects (update-exp (find-argument problem-def :init) alist new-objects)
;; 		     (update-exp (give-me-all-goals problem-def) alist new-objects)
;; 		     (concatenate 'string probsets-dir new-problem-file)
;; 		     (find-argument problem-def :metric))
;;     (list agent-types internal-predicates)))

;; adds to the list of agent types those that are super-types of agent-types, such that all subtypes of those types are
;; agent-types
(defun augment-agent-types (agent-types types)
  (do* ((the-types types (if changep types (cdr the-types)))
	(changep nil nil)
	(new-agent-types agent-types))
       ((null the-types) new-agent-types)
    (when (and (subsetp (cdar the-types) new-agent-types)
	       (not (member (caar the-types) new-agent-types)))
      (push (caar the-types) new-agent-types)
      (setq changep t))))

;; given some predicate args (or action parameters), and a list of agent-types, it returns the types of the arguments of
;; the predicate (action parameters) that have as subtypes both agents and non-agents, as well as those that are
;; subtypes.  This type of definitions cannot be handled by MAPR/CMAP, since they assume predicates cannot be shared by
;; agents and non-agents. Example: (at ?obj - physobj ?loc - location) where physobj can be vehicles or packages where
;; vehicles are agents and packages are not
(defun compute-mixed-parameters (agent-types parameters types-def non-agent-types &optional predicates-args)
  (declare (special *predicates-in-action*))
  (do* ((args parameters (cdddr args))
	(subtypes (if args (sub-types (list (caddr args)) types-def))
		  (if args (sub-types (list (caddr args)) types-def)))
	(mixed-parameters nil)
	(i 0 (1+ i))
	(agent-sub-types (intersection subtypes agent-types) (intersection subtypes agent-types))
	(non-agent-sub-types (intersection subtypes non-agent-types) (intersection subtypes non-agent-types)))
       ((null args) mixed-parameters)
    (if (or (and agent-sub-types non-agent-sub-types)
	    (and subtypes
		 (some #'(lambda (predicate)
			   (let ((position1 (position (car args) predicate))
				 (position2 (cdr (assoc (car predicate) predicates-args))))
			     (and position1 position2 (= position1 (1+ position2)))))
		       *predicates-in-action*)))
	(push (cons (caddr args) (cons i subtypes)) mixed-parameters))))

;; changes all mixed-parameters predicates/functions into their non problematic versions
(defun update-action (action-def alist agent-types non-agent-types leaf-types types predicates-args)
  (let* ((parameters (cleanup-params (cadr (member :parameters action-def))))
	 (mixed-parameters nil)
	 (preconditions (cadr (member :precondition action-def)))
	 (effects (cadr (member :effect action-def)))
	 (new-name nil)
	 (cross-product nil)
	 (leaves nil)
	 (new-parameters nil)
	 (alist-member-fn #'(lambda (exp) (assoc (car exp) alist))))
    (setf *predicates-in-action* nil)
    (collect-predicates preconditions alist-member-fn)
    (collect-predicates effects alist-member-fn)
    (setq mixed-parameters (compute-mixed-parameters agent-types parameters types non-agent-types predicates-args))
    (cond (mixed-parameters
	   (dolist (mixed-parameter mixed-parameters)
	     (setq leaves (intersection leaf-types (cddr mixed-parameter)))
	     (if cross-product
		 (dolist (leaf-type leaves)
		   (setq cross-product (mapcar #'(lambda (subtypes)
						   (cons (cons (car mixed-parameter) leaf-type) subtypes))
					       cross-product)))
		 (setq cross-product (mapcar #'(lambda (leaf) (list (cons (car mixed-parameter) leaf))) leaves))))
	   (mapcan #'(lambda (types-alist)
		       (setq new-name (intern (format nil "~:@(~{~a-~}~a~)" (mapcar #'cdr types-alist) (cadr action-def))))
		       (push (cons new-name (cadr action-def)) *ma-pddl-alist*)
		       (setq new-parameters (sublis types-alist parameters))
		       (list `(:action ,new-name :parameters ,new-parameters ;; ,(sublis (list (cons )))
				       :precondition ,(update-exp preconditions alist new-parameters)
				       :effect ,(update-exp effects alist new-parameters))))
		   cross-product))
	  (t (list `(,@(subseq action-def 0 (position :precondition action-def))
		      :precondition ,(update-exp preconditions alist parameters)
		      :effect ,(update-exp effects alist parameters)))))))

(defun update-exp (exp alist parameters)
  (case (car exp)
    ((and or)
     (let ((result (update-exp (cdr exp) alist parameters)))
       (if result (cons (car exp) result))))
    (not (let ((result (update-exp (cadr exp) alist parameters)))
	   (if result (cons (car exp) (list result)))))
    ((increase assign <= >= + * - / < > when)
     (let ((result1 (update-exp (cadr exp) alist parameters))
	   (result2 nil))
       (when result1
	 (setq result2 (if (numberp (caddr exp))
			   (caddr exp)
			   (update-exp (caddr exp) alist parameters)))
	 (if result2 (list (car exp) result1 result2)))))
    ((forall exists)
     (let ((result1 (update-exp (caddr exp) alist parameters)))
       (if result1 (list (car exp) (cadr exp) result1))))
    (otherwise ;; I hope list of literals or individual literal
     (let (found var-new-names)
       (cond ((listp (car exp))
	      (mapcar #'(lambda (subexp) (update-exp subexp alist parameters))
		      exp))
	     ((setq found (assoc (car exp) alist))
;; 	      (format t "~%found: ~a~%" found)
	      (setq var-new-names (mapcan #'(lambda (apair)
					      (do ((params (reverse parameters) (cdddr params))
						   (var-names nil))
						  ((null params) var-names)
						(if (eq (car apair) (car params))
						    (push (cons (caddr params) (cdr apair)) var-names))))
					  (cdr found)))
;; 	      (format t "~%var: ~a~%" var-new-names)
	      ;; I am assuming again only one mixed-parameter per predicate/function
	      (cons (cdr (some #'(lambda (arg) (assoc arg var-new-names))
			       (cdr exp)))
		    (cdr exp)))
	     (t exp))))))

;; to replace back the original names of actions
(defun pddl-to-ma-pddl-solution (solution)
   (sublis *ma-pddl-alist* solution))
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; It performs goal-allocation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; It allocates public goals among agents according to the goal-selection parameter
(defun goal-allocation (internal-predicates goal-selection sort-agents domain probsets-dir domain-dir run-mapr-p)
  (write-message "Allocating goals to agents" nil)
  (let ((init-time (get-internal-real-time))
	;; only needed for subsets and all
	(relevant-agents nil))
    (if (and (or (eq goal-selection 'rest-achievable)
		 (eq goal-selection 'best-cost)
		 (eq goal-selection 'load-balance)
		 (eq goal-selection 'contract-net))
	     (or (eq sort-agents 'name)
		 (eq sort-agents 'random)))
	(sort-agents sort-agents))
    ;; in order to allow MAPR to solve Logistics (et al.) problems
    (case goal-selection
      ;; we select all agents
      (all (setq relevant-agents *agents*))
      (subgoals (assign-only-private-goals internal-predicates probsets-dir))
      (subsets (setq relevant-agents (allocate-subsets domain probsets-dir)))
      (contract-net (allocate-contract-net domain probsets-dir domain-dir))
      ((all-achievable rest-achievable load-balance best-cost)
       ;; compute heuristic for each agent and goal
       (compute-agents-votes internal-predicates domain probsets-dir)
       ;; assign goals to agents according to goal-selection criteria
       (allocate-goals goal-selection))
      (otherwise nil))
    (unless (eq goal-selection 'all)
    ;; assign goals that were not reachable by any agent
      (allocate-unassigned-goals internal-predicates domain domain-dir probsets-dir run-mapr-p)
      ;; remove from *agents* the ones that did not get any goal
      (filter-agents relevant-agents)
      ;; sort agents again
      (sort-agents sort-agents)
      (assign-goals-in-problem-files probsets-dir))
    (if *trace-ma-sayphi* (format t "~%Goals assignment time: ~,2f" (elapsed-time init-time 'real-time)))))

;; It assigns only the private goals
(defun assign-only-private-goals (internal-predicates probsets-dir)
  (let (internal-preds)
    (dolist (agent *agents*)
      (setq internal-preds (sublis (agent-anonymize-list agent) internal-predicates))
      (dolist (goal (give-me-all-goals (cdr (read-all-file (concatenate 'string probsets-dir (agent-problem-file agent))))))
	(when (member (car goal) internal-preds)
	  (if *trace-ma-sayphi* (format t "~%Private goal ~a assigned to agent ~a" goal agent))
	  (push (cons goal 0) (agent-votes agent))
	  (push goal (agent-assigned-goals agent)))))))

;; It computes the heuristic value of each agent and goal
(defun compute-agents-votes (internal-predicates domain probsets-dir)
  (dolist (agent *agents*)
    (compute-agent-votes agent internal-predicates domain probsets-dir)))

;; It computes the heuristic value of an agent and each goal
;; I need Sayphi for this computation. We could also call another planner to generate a solution, but it would take more
;; time than computing the relaxed plan
(defun compute-agent-votes (agent internal-predicates domain probsets-dir)
  (declare (special *current-problem* *trace-ma-sayphi*))
  (say-domain domain (agent-domain-file agent) nil)
  (prob (concatenate 'string probsets-dir (agent-problem-file agent)) nil)
  (set-duplicate-hashing)
  (let ((internal-preds (sublis (agent-anonymize-list agent) internal-predicates))
	(heuristic 0))
    (if *trace-ma-sayphi* (format t "~2%Agent ~a" agent (compute-heuristic (problem-lit-goals *current-problem*))))
    (dolist (goal (problem-lit-goals *current-problem*))
      (cond ((member (car goal) internal-preds)
	     (if *trace-ma-sayphi* (format t "~%Private goal ~a inserted with heuristic ~,2f" goal heuristic))
	     (if (< (compute-heuristic (list goal)) most-positive-fixnum)
		 (push (cons goal 0) (agent-votes agent))
		 (push (cons goal most-positive-fixnum) (agent-votes agent))))
	    (t (push (cons goal (compute-heuristic (list goal))) (agent-votes agent)))))))

;; in case of domains with costs, I am not sure why, but it returns a 0
(defun compute-heuristic (&optional goals (i-node (initialize-current-problem)))
  (if goals (setf (problem-goals *current-problem*) (literalgoals-bitmap goals)))
  (multiple-value-bind (heuristic relaxed-plan) (h-metric-rxplan i-node)
    (if *goals-not-in-pspace* ;; some goals were not in the pspace (detected by literalgoals-bitmap)
	(setq heuristic most-positive-fixnum)
	(if (and (= 0 heuristic) relaxed-plan)
	    (setq heuristic (length relaxed-plan))))
    (if *trace-ma-sayphi*
	(format t "~%Goals: ~a~%Heuristic: ~,2f~%Relaxed plan: ~a"
		goals heuristic (if (< heuristic most-positive-fixnum) relaxed-plan)))
    (values heuristic relaxed-plan)))


(defun allocate-goals (goal-selection)
  (case goal-selection
    ((all-achievable all) (allocate-all-achievable))
    (rest-achievable (allocate-rest-achievable))
    (best-cost (allocate-best-cost))
    (load-balance (allocate-load-balance))
    (subset)
    (t nil)))

;; It allocates to each agent all goals it can achieve
(defun allocate-all-achievable nil
  (dolist (agent *agents*)
    (dolist (goal-vote (agent-votes agent))
      (if (< (cdr goal-vote) most-positive-fixnum)
	  (push (car goal-vote) (agent-assigned-goals agent))))))


;; It allocates all goals that the first agent can achieve to the first agent.
;; Then, it removes those goals from the set of goals that can be assigned and proceeds with the rest of agents.
(defun allocate-rest-achievable nil
  (let (assigned-goals)
    (dolist (agent *agents*)
      (dolist (goal-vote (agent-votes agent))
	(when (and (< (cdr goal-vote) most-positive-fixnum)
		   (not (member (car goal-vote) assigned-goals :test #'equal)))
	  (push (car goal-vote) (agent-assigned-goals agent))
	  (push (car goal-vote) assigned-goals))))))

;; It allocates each goal to the best agent
(defun allocate-best-cost nil
  (let ((best-vote most-positive-fixnum)
	(best-agent nil)
	(agent-vote nil))
    ;; assignment of public goals
    (dolist (goal *public-goals*)
      (setq best-vote most-positive-fixnum)
      (setq best-agent nil)
      (dolist (agent *agents*)
	(setq agent-vote (car (member goal (agent-votes agent) :test #'(lambda (g v) (equal g (car v))))))
	(when (and agent-vote (< (cdr agent-vote) best-vote))
	  (setq best-vote (cdr agent-vote))
	  (setq best-agent agent)))
      (if best-agent
	  (push goal (agent-assigned-goals best-agent))))
    (assign-private-goals *public-goals*)))

;; assignment of private goals
(defun assign-private-goals (public-goals)
  (dolist (agent *agents*)
    (dolist (goal-vote (agent-votes agent))
      (if (not (member (car goal-vote) public-goals :test #'equal))
	  (push (car goal-vote) (agent-assigned-goals agent))))))

;; It allocates each goal to the best agent until the best gets more goals than the average balance.
;; Then it removes that agent from the pool of assignable agents
;; I assume there is one or more agents
(defun allocate-load-balance nil
  (let* ((best-vote most-positive-fixnum)
	 (best-agent nil)
	 (agent-vote nil)
	 (balance (ceiling (length *public-goals*) (length *agents*)))
	 (agents *agents*)
	 (assigned-goals nil))
    ;; assignment of public goals
    (dolist (goal *public-goals*)
      (setq best-vote most-positive-fixnum)
      (setq best-agent nil)
      (dolist (agent agents)
	(setq agent-vote (car (member goal (agent-votes agent) :test #'(lambda (g v) (equal g (car v))))))
	(when (and agent-vote (< (cdr agent-vote) best-vote))
	  (setq best-vote (cdr agent-vote))
	  (setq best-agent agent)))
      ;; if there is no best agent, it can be because no agent can achieve it, or because the ones that can are already
      ;; full. Those goals will be later assigned to the first agent. There could be other better ways to perform load
      ;; balancing.
      (when best-agent
	(push goal (agent-assigned-goals best-agent))
	(push goal assigned-goals)
	(if (>= (length (agent-assigned-goals best-agent)) balance)
	    (setq agents (remove best-agent agents)))))
    ;; assignment of unassigned goals due to load-balance
    (dolist (goal (set-difference *public-goals* assigned-goals :test #'equal))
      (setq best-vote most-positive-fixnum)
      (setq best-agent nil)
      (dolist (agent *agents*)
	(setq agent-vote (car (member goal (agent-votes agent) :test #'(lambda (g v) (equal g (car v))))))
	(when (< (cdr agent-vote) best-vote)
	  (setq best-vote (cdr agent-vote))
	  (setq best-agent agent)))
      (if best-agent
	  (push goal (agent-assigned-goals best-agent))))
    ;; assignment of private goals
    (assign-private-goals *public-goals*)))

(defun allocate-contract-net (domain probsets-dir domain-dir)
  (declare (special *current-problem* *trace-ma-sayphi*))
  (say-domain domain *merged-domain* nil)
  (let* ((problem-def (cdr (read-all-file (concatenate 'string probsets-dir *merged-problem*))))
	 (all-goals (give-me-all-goals problem-def))
	 (domain-def nil)
	 (heuristic 0)
	 (goals-in-problem nil))
    ;; assignment of private goals
    (assign-private-goals-subsets-contract-net all-goals)
    (do* ((public-goals *public-goals* (cdr public-goals))
	  (goal (car public-goals) (car public-goals))
	  (best-agent nil nil)
	  (best-cost most-positive-fixnum most-positive-fixnum))
	((null public-goals))
      (dolist (agent *agents*)
	(if *joint-actions-p*
	    (setq domain-def (cdr (read-all-file (concatenate 'string domain-dir (agent-domain-file agent))))))
	(when (or (not *joint-actions-p*) (member (car goal) (find-argument domain-def :predicates) :key #'car))
	  (setq problem-def (cdr (read-all-file (concatenate 'string probsets-dir (agent-problem-file agent)))))
	  (setq goals-in-problem (find-argument problem-def :goal))
	  (if (eq (caar goals-in-problem) 'and)
	      (setf (cdadr (assoc :goal problem-def))
		    (cons goal (agent-assigned-goals agent)))
	      (setf (cdr (assoc :goal problem-def))
		    (cons 'and (cons goal (agent-assigned-goals agent)))))
	  (parse-problem problem-def)
	  (set-duplicate-hashing)
	  (setq heuristic (compute-heuristic))
	  (if *trace-ma-sayphi*
	      (format t "~%Agent: ~a, Goals: ~a, heuristic: ~,2f" agent (assoc :goal problem-def) heuristic))
	  (when (< heuristic best-cost)
	    (setq best-cost heuristic)
	    (setq best-agent agent))))
      (if *trace-ma-sayphi* (format t "~%Assigned agent ~a for goal ~a via contract-net" best-agent goal))
      (if best-agent (push goal (agent-assigned-goals best-agent))))))
;; 	(write-problem problem-def probsets-dir (agent-problem-file agent))
;; 	(load-prob (agent-problem-file agent) nil)

;; It computes subsets of agents that can solve in combination each goal
;; It returns a list of agents that should be used, given that they belong to a relaxed problem
;; of at least one of the goals. This allows to solve problems in logistics or elevators
(defun allocate-subsets (domain probsets-dir)
  (declare (special *current-problem* *trace-ma-sayphi* *agents*))
  (say-domain domain *merged-domain* nil)
  (let* ((problem-def (cdr (read-all-file (concatenate 'string probsets-dir *merged-problem*))))
	 (all-goals (give-me-all-goals problem-def))
	 (i-node nil)
	 (state nil)
	 (public-goals nil)
	 (relevant-agents nil)
	 (action-in-plan nil)
	 (agent-in-plan nil)
	 (last-agent nil))
    (parse-problem problem-def)
    (set-duplicate-hashing)
    (setq i-node (initialize-current-problem))
    (setq state (give-me-nice-sayphi-state i-node))
    (setq public-goals (remove-if #'(lambda (goal) (member goal state :test #'equal)) *public-goals*))
    (multiple-value-bind (heuristic relaxed-plan) (compute-heuristic public-goals i-node)
      (if *trace-ma-sayphi*
	  (format t "~2%Relaxed plan: ~a~%Goals: ~a~%Heuristic: ~,2f" relaxed-plan public-goals heuristic))
      (cond ((< heuristic most-positive-fixnum)
	     ;; it computes the subset of agents that appear in the relaxed-plan
	     (dolist (step relaxed-plan)
	       (setq action-in-plan (car (gaction-planaction step)))
	       (if relaxed-plan
		   ;; it maintains privacy, since each agent will reply of
		   ;; whether it is part of the relaxed plan or not
		   (setq agent-in-plan (find-if #'(lambda (agent)
						    (assoc action-in-plan (agent-reverse-anonymize-list agent)))
						*agents*)))
	       (when agent-in-plan
		 (pushnew agent-in-plan relevant-agents)
		 (setq last-agent agent-in-plan)))
	     ;; last-agent can be nil if the relaxed-plan does not contain any agent (goals can be achieved
	     ;; without agents)
	     ;; Perhaps it would be better to assign it to the first one
	     (if last-agent
		 (dolist (goal public-goals)
		   (push goal (agent-assigned-goals last-agent)))))
	    (t (if *trace-ma-sayphi* (format t "~%Unreachable goal ~a" public-goals)))))
    ;; assignment of private goals
    (assign-private-goals-subsets-contract-net all-goals)
    relevant-agents))

(defun assign-private-goals-subsets-contract-net (all-goals)
  (dolist (goal (set-difference all-goals *public-goals* :test #'equal))
    (dolist (agent *agents*)
      (if (assoc (car goal) (agent-reverse-anonymize-list agent))
	  (push goal (agent-assigned-goals agent))))))


;; I remove all agents that did not get any goal assigned
(defun filter-agents (relevant-agents)
  (if (not *policy*)
      (setf *agents* (remove-if #'(lambda (agent)
				    (and (not (member agent relevant-agents))
					 (not (agent-assigned-goals agent))
					 (not (agent-subgoals agent))))
				*agents*))))

;; it sorts the list of *agents*
(defun sort-agents (sort-agents)
  (setf *agents*
	(case sort-agents
	  (name (sort *agents* #'string-lessp :key #'agent-name))
	  (random (shuffle *agents*))
	  (maxgoals (sort *agents* #'> :key #'(lambda (agent) (length (agent-assigned-goals agent)))))
	  (mingoals (sort *agents* #'< :key #'(lambda (agent) (length (agent-assigned-goals agent)))))
	  ;; if there is a policy, they have been previously ordered in the function assign-subgoals.
	  ;; otherwise, I use mingoals given its good behavior
	  (subgoals (if *policy*
			*agents*
			(sort *agents* #'< :key #'(lambda (agent) (length (agent-assigned-goals agent))))))
	  (otherwise *agents*))))

;; I assume in the *agents* list the only agents left are the ones to be assigned goals
(defun assign-goals-in-problem-files (probsets-dir)
  (dolist (agent *agents*)
    (let ((problem-def (cdr (read-all-file (concatenate 'string probsets-dir (agent-problem-file agent))))))
      (write-pddl-file (cadar problem-def) (car (find-argument problem-def :domain))
		       (find-argument problem-def :objects) (find-argument problem-def :init)
		       (cons 'and (agent-assigned-goals agent))
		       (concatenate 'string probsets-dir (agent-problem-file agent))
		       (find-argument problem-def :metric)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;   Dealing with goals that cannot be reached by agents alone
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; It assigns public goals that are not reachable by any agent to the first one. In domains as sokoban, there might be
;; public goals that are not reachable by any agent, and nevertheless we can find solutions.
(defun allocate-unassigned-goals (internal-predicates domain domain-dir probsets-dir run-mapr-p)
  (let* ((assigned-goals (mapcan #'(lambda (agent) (copy-list (agent-assigned-goals agent))) *agents*))
	 (unassigned-goals (set-difference *all-public-goals* assigned-goals :test #'equal))
	 (first-agent-with-goals nil))
    (if *trace-ma-sayphi* (format t "~2%Assigning unassigned goals: ~a" unassigned-goals))
    (when unassigned-goals
      (cond (run-mapr-p (augment-goals unassigned-goals internal-predicates domain domain-dir probsets-dir))
	    (t (setq first-agent-with-goals (or (find-if #'(lambda (agent) (agent-assigned-goals agent)) *agents*)
						(car *agents*)))
	       (dolist (ugoal unassigned-goals)
		 (push ugoal (agent-assigned-goals first-agent-with-goals))))))))

;; It follows Crosby, Rovatsos & Petrick algorithm for computing extra subgoals for agents, so that MAPR can solve
;; Logistics (et al.) problems
(defun augment-goals (unassigned-goals internal-predicates domain domain-dir probsets-dir)
  (write-message "Computing subgoals and assigning them to agents for MAPR" nil)
  (dolist (agent *agents*)
    (push (cons agent (agent-assigned-goals agent)) *achievable-by*))
  (do* ((num-agents (length *agents*))
	(agents *agents*)
	(agents-names (mapcar #'agent-name agents))
	(agent (car agents) (car agents))
	(finish-agent nil)
	(state nil)
	(new-state nil)
	(unachieved-goals unassigned-goals)
	(private-info nil)
	(anonymize-list nil)
	(domain-def nil)
	(problem-def nil)
	(agents-facts (mapcar #'(lambda (agent) (cons agent nil)) agents))
	(achievable-facts nil)
	(new-achievable-facts nil)
	(iterations 0)
	(number-iterations-no-change 0)
;; 	(domain-predicates nil)
	(heuristic most-positive-fixnum)
	(relaxed-plan nil)
	(all-last-facts nil))
       ((or finish-agent (>= number-iterations-no-change num-agents))
	(if (or (not finish-agent) unachieved-goals)
	    (setf *unreachable-goals* unachieved-goals)
	    (if (or (> iterations 0) (not unachieved-goals))
		(compute-policy relaxed-plan private-info agents-facts unassigned-goals new-state state
				finish-agent agents-names internal-predicates domain domain-dir probsets-dir))))
    (if *trace-ma-sayphi* (format t "~2%Agent ~a" agent))
    (setq private-info (agent-reverse-anonymize-list agent))
    (setq anonymize-list (agent-anonymize-list agent))
    (setq domain-def (cdr (read-all-file (concatenate 'string domain-dir (agent-domain-file agent)))))
    (parse-domain domain-def)
;;     (say-domain domain (agent-domain-file agent) nil)
;;     (setq domain-predicates (domain-predicates))
    (setq problem-def (cdr (read-all-file (concatenate 'string probsets-dir (agent-problem-file agent)))))
    (setq state (find-argument problem-def :init))
    (setq new-state (remove-invalid-predicates (union state achievable-facts :test #'equal)
					       (agent-predicates agent)
					       (process-types (find-argument domain-def :types))
					       (process-instances (find-argument problem-def :objects))))
;;     (setq new-state (remove-if-not #'(lambda (literal) (or (member (car literal) domain-predicates)
;; 							   (eq (car literal) '=)))
;; 				   (union state achievable-facts :test #'equal)))
    (setf (nth 3 problem-def) (cons :init new-state))
    (parse-problem problem-def)
    (set-duplicate-hashing)
    (if *trace-ma-sayphi* (format t "~%Agent facts: ~a" agents-facts))
;;     (setq new-goals unachieved-goals)
    (multiple-value-setq (heuristic relaxed-plan) (compute-heuristic unachieved-goals))
    (setq all-last-facts (all-last-facts))
    (setq new-achievable-facts (remove-private-info (set-difference all-last-facts new-state :test #'equal)
						    agent agents-names internal-predicates private-info t))
    (setq unachieved-goals (set-difference unachieved-goals all-last-facts :test #'equal))
    (if *trace-ma-sayphi* (format t "~%All achievable facts: ~a~%New achievable facts: ~a~%Unachieved goals: ~a"
				  all-last-facts new-achievable-facts unachieved-goals))
    (dolist (fact new-achievable-facts)
      ;;       (pushnew (sublis anonymize-list fact :test #'equal) (cdr (assoc agent *achievable-by*)) :test #'equal)
      (pushnew fact (cdr (assoc agent *achievable-by*)) :test #'equal))
    (cond ((< heuristic most-positive-fixnum)
	   (setq finish-agent agent)
;; 	   (format t "~%Finish agent: ~a" finish-agent)
	   (setf (cdr (assoc agent agents-facts))
		 (cons (list achievable-facts new-achievable-facts)
		       (cdr (assoc agent agents-facts)))))
	  (new-achievable-facts
	   (setq number-iterations-no-change 0)
	   (setf (cdr (assoc agent agents-facts))
		 (cons (list achievable-facts new-achievable-facts)
		       (cdr (assoc agent agents-facts))))
	   (setq achievable-facts (union achievable-facts new-achievable-facts :test #'equal)))
	  (t (incf number-iterations-no-change)))
    (cond ((cdr agents) (setq agents (cdr agents)))
	  (t (setq agents *agents*)
	     (incf iterations)))))

(defun compute-policy (relaxed-plan private-info agents-facts unassigned-goals new-state state
		       finish-agent agents-names internal-predicates domain domain-dir probsets-dir)
  (setq relaxed-plan (remove-if #'(lambda (gaction) (member (car (gaction-planaction gaction)) private-info))
				relaxed-plan))
  (assign-subgoals agents-facts)
  (compute-agents-subgoals unassigned-goals agents-facts
			   (remove-private-info
			    (set-difference (intersection new-state
							  (union-preconds-relaxed-plan unassigned-goals relaxed-plan)
							  :test #'equal)
					    state :test #'equal)
			    finish-agent agents-names internal-predicates private-info nil)
			   internal-predicates domain domain-dir probsets-dir)
  (if *trace-ma-sayphi* (format t "~2%Policy: ~a" *policy*))
  (dolist (agent *agents*)
    (if (and (agent-assigned-goals agent)
	     (not (assoc agent *policy*)))
	(push (list agent nil nil nil) *policy*)))
  (setq *agents* nil)
  (dolist (agent-subgoals *policy*)
    (pushnew (car agent-subgoals) *agents*))
  (setf *achievable-by* (remove-if-not #'(lambda (agent-goals) (member (car agent-goals) *agents*)) *achievable-by*))
  (setf *agents* (nreverse *agents*)))
	      
	      
;; Assigns subgoals to agents that can achieve them
;; It computes a policy, that is an ordered list of sublists. Each sublist has an agent, and a list of lists of subgoals
;; in the order in which it has to achieve them.
(defun assign-subgoals (agents-facts)
;;   (if *trace-ma-sayphi* (format t "~%Agents facts: ~a~%Policy: ~a" agents-facts *policy*))
  (do ((causal-structure agents-facts)
       (current-state nil)
       (new-causal-structure agents-facts)
       (new-list nil)
       (found t))
      ((or (not found) (not causal-structure))
       (setf *policy* (nreverse *policy*))
       (if *trace-ma-sayphi* (format t "~%Agents facts: ~a~%Policy: ~a" agents-facts *policy*)))
    (setq found nil)
;;     (if *trace-ma-sayphi* (format t "~%Causal structure: ~a" causal-structure))
    (dolist (agent-facts causal-structure)
      (cond ((cdr agent-facts)
	     (some #'(lambda (init-goals)
;;  		       (if *trace-ma-sayphi* (format t "~%State&goals: ~a~%Current state: ~a" init-goals current-state))
		       (cond ((subsetp (car init-goals) current-state :test #'equal)
;; 			      (if *trace-ma-sayphi* (format t "~%Matches"))
			      (push (cons (car agent-facts) (cadr init-goals)) *policy*)
			      (setq current-state (union (cadr init-goals) current-state :test #'equal))
			      (setq found init-goals))
			     (t (push init-goals new-list)
				nil)))
		   (cdr agent-facts))
	     (when found
	       (setq new-causal-structure (remove agent-facts new-causal-structure :test #'equal))
	       (push (cons (car agent-facts) (remove found (cdr agent-facts) :test #'equal))
		     new-causal-structure)))
	    (t nil)))
    (setq causal-structure new-causal-structure)))

(defun compute-agents-subgoals (unassigned-goals agents-facts weakest-preconds
				internal-predicates domain domain-dir probsets-dir)
  (declare (special *removed-goals*))
  (let* ((reverse-policy (reverse *policy*))
	 (iterations (length *policy*))
	 (previous-subgoals (intersection (cdar (last *policy*)) unassigned-goals :test #'equal))
	 (previous-weakest-preconds (remove-if #'(lambda (literal) (member (car literal) *static-predicates*))
					       weakest-preconds))
	 (new-goals nil)
	 (remove-goals nil)
	 (agents-names (mapcar #'agent-name *agents*))
	 (achievable-facts nil)
	 (state nil)
	 (new-state nil)
	 (domain-predicates nil)
	 (private-info nil)
	 (domain-def nil)
	 (problem-def nil)
	 (all-subgoals (union unassigned-goals weakest-preconds :test #'equal))
	 (heuristic most-positive-fixnum)
	 (relaxed-plan nil))
    (if *trace-ma-sayphi* (format t "~%Unassigned goals: ~a" unassigned-goals))
    (setf *removed-goals* nil)
    (setf (cdar (last *policy*)) (list (remove-if-not-in-domain unassigned-goals (domain-predicates))
				       nil weakest-preconds))
    ;;     (setf (cdar (last *policy*)) unassigned-goals)
    (setq reverse-policy (reverse *policy*))
    (do* ((iteration (1- iterations) (1- iteration))
	  (policy (cdr reverse-policy) (cdr policy))
	  (agent (caar policy) (caar policy))
	  (subgoals (cdar policy) (cdar policy)))
	 ((null policy)
	  (if *trace-ma-sayphi* (format t "~%New policy: ~a" *policy*)))
      (if *trace-ma-sayphi* (format t "~%New policy: ~a~%Subgoals: ~a~%All subgoals: ~a" *policy* subgoals all-subgoals))
      (setq subgoals (intersection subgoals all-subgoals :test #'equal))
      (cond (subgoals
	     (setq private-info (agent-reverse-anonymize-list agent))
	     (setq domain-def (cdr (read-all-file (concatenate 'string domain-dir (agent-domain-file agent)))))
	     (parse-domain domain-def)
;; 	     (say-domain domain (agent-domain-file agent) nil)
	     (setq domain-predicates (domain-predicates))
	     (dolist (removed-goal *removed-goals*)
	       (when (member (car removed-goal) domain-predicates)
		 (pushnew removed-goal subgoals :test #'equal)
		 (setf *removed-goals* (remove removed-goal *removed-goals* :test #'equal))))
	     (setq problem-def (cdr (read-all-file (concatenate 'string probsets-dir (agent-problem-file agent)))))
	     (setq state (find-argument problem-def :init))
	     (some #'(lambda (init-goals)
		       (cond ((equal-set-p (cadr init-goals) (cdar policy))
			      (setq achievable-facts (car init-goals))
			      t)
			     (t nil)))
		   (cdr (assoc agent agents-facts)))
	     (setq new-state (remove-invalid-predicates (union state achievable-facts :test #'equal)
							(agent-predicates agent)
							(process-types (find-argument domain-def :types))
							(process-instances (find-argument problem-def :objects))))
;; 	     (setq new-state (remove-if-not #'(lambda (literal)
;; 						(or (member (car literal) domain-predicates)
;; 						    (eq (car literal) '=)))
;; 					    (union state achievable-facts :test #'equal)))
	     (if *trace-ma-sayphi*
		 (format t "~%Agent: ~a~%Achievable-facts: ~a~%Goals: ~a~%New state: ~a"
			 agent achievable-facts subgoals new-state))
	     (setf (nth 3 problem-def) (cons :init new-state))
	     (setf (nth 4 problem-def) (cons :goal (list (cons 'and subgoals))))
	     (parse-problem problem-def)
	     (set-duplicate-hashing)
	     (multiple-value-setq (heuristic relaxed-plan) (compute-heuristic))
	     (setq weakest-preconds
		   (remove-private-info (intersection new-state
						      (union-preconds-relaxed-plan subgoals relaxed-plan)
						      :test #'equal)
					agent agents-names internal-predicates private-info nil))
	     (setq new-goals (union (set-difference (union (cadr (nth iteration *policy*)) (caddr (nth iteration *policy*))
							   :test #'equal)
						    previous-subgoals :test #'equal)
				    (union subgoals previous-weakest-preconds :test #'equal)
				    :test #'equal))
	     ;; weakest-preconds of previous iteration
	     (setf (cdr (nth (1- iteration) *policy*))
		   (list (remove-if-not-in-domain (intersection new-goals previous-weakest-preconds :test #'equal) domain-predicates)
			 (remove-if-not-in-domain (set-difference new-goals previous-weakest-preconds :test #'equal) domain-predicates)
			 weakest-preconds))
	     (if *trace-ma-sayphi*
		 (format t "~%WP: ~a~%PWP: ~a~%Goals: ~a~%Previous subgoals: ~a"
			 weakest-preconds previous-weakest-preconds new-goals previous-subgoals))
	     (setq previous-weakest-preconds weakest-preconds)
	     ;; 	     (setf (cdr (nth (1- iteration) *policy*))
	     ;; 		   (union weakest-preconds
	     ;; 			  (set-difference (cdr (nth iteration *policy*)) previous-subgoals :test #'equal)
	     ;; 			  :test #'equal))
	     (setq previous-subgoals subgoals)
	     (dolist (precond weakest-preconds)
	       (pushnew precond all-subgoals :test #'equal))
	     ;; really irrelevant, given that we will use the policy
	     (dolist (goal subgoals)
	       (when (member goal unassigned-goals :test #'equal)
		 (setq unassigned-goals (remove goal unassigned-goals :test #'equal))
		 ;; 	  (pushnew goal (agent-assigned-goals agent) :test #'equal)
		 (if *trace-ma-sayphi* (format t "~%Assigning ~a to ~a" goal agent)))))
	    ;; the corresponding agent that doesn't add anything useful
	    (t (if *trace-ma-sayphi* (format t "~%Agent ~a does not add any useful subgoal. It is removed from policy" agent))
	       (setf *policy* (remove (car policy) *policy* :test #'equal)))))))

(defun remove-private-info (list agent agents-names internal-predicates private-info only-internal-p)
  (remove-if #'(lambda (literal)
		 (let ((binding (assoc (car literal) private-info)))
		   (if binding
		       (if only-internal-p
			   (member (cdr binding) internal-predicates)
			   (includes-agent-alone-p (car literal) (cdr binding) (agent-name agent) agents-names)))))
	     list))

(defun includes-agent-alone-p (new-predicate original-predicate agent-name agents-names)
  (let (result array)
    (multiple-value-setq (result array)
      (cl-ppcre:scan-to-strings
       (cl-ppcre:create-scanner (format nil "(anon-|rename-)*~a(-[-_a-zA-Z0-9]*)*-(~a)(-[-_a-zA-Z0-9]*)*"
					original-predicate agent-name)
				:case-insensitive-mode t)
       (format nil "~a" new-predicate)))
    (and array
	 (or (not (or (elt array 1) (elt array 3)))
	     (notany #'(lambda (another-agent-name)
			 (let ((scanner (cl-ppcre:create-scanner (format nil "(-[-_a-zA-Z0-9]*)*-~a(-[-_a-zA-Z0-9]*)*"
									 another-agent-name)
								 :case-insensitive-mode t)))
			   (or (cl-ppcre:scan-to-strings scanner (elt array 1))
			       (cl-ppcre:scan-to-strings scanner (elt array 3)))))
		     agents-names)))))

(defun remove-if-not-in-domain (literals domain-predicates)
  (remove-if-not #'(lambda (literal)
		     (let ((found (member (car literal) domain-predicates)))
		       (cond (found t)
			     (t (push literal *removed-goals*)
				nil))))
		 literals))
    
;; avoids problems with bogus relaxed plans (with actions that accidentally add something that is not really needed and
;; can be achieved by other actions in the relaxed-plan)
(defun union-preconds-relaxed-plan (goals relaxed-plan)
  (do ((union-preconds-relaxed-plan nil)
       (achievers (mapcar #'(lambda (action) (cons action (compute-action-elements action 'adds)))
			  relaxed-plan))
       (preconds (mapcar #'(lambda (action)
			     (cons action (remove-if #'(lambda (literal)
							 (member (car literal) *static-predicates* :test #'equal))
						     (compute-action-elements action 'preconditions))))
			 relaxed-plan))
       (max-count 0)
       (count 0)
       (relevant-actions relaxed-plan)
       (max-action nil)
       (new-subgoals nil)
       (endp nil)
       (unachieved-goals goals))
      ((or endp (null unachieved-goals)) union-preconds-relaxed-plan)
    (setq max-count 0)
    (setq max-action nil)
    (dolist (action relevant-actions)
      (setq count (count-if #'(lambda (subgoal)
				(member subgoal (cdr (assoc action achievers)) :test #'equal))
			    unachieved-goals))
      (when (> count max-count)
	(setq max-count count)
	(setq max-action action)))
    (cond (max-action
	   (setq relevant-actions (remove max-action relevant-actions))
	   (setq new-subgoals (cdr (assoc max-action preconds)))
	   (setq unachieved-goals (union new-subgoals
					 (set-difference unachieved-goals (cdr (assoc max-action achievers)) :test #'equal)
					 :test #'equal))
	   (setq union-preconds-relaxed-plan (union union-preconds-relaxed-plan new-subgoals :test #'equal)))
	  (t (setq endp t)))))

(defun compute-action-elements (gaction element-type)
  (let* ((action (gaction-planaction gaction))
	 (action-name (car action))
	 (action-struct (find action-name (dom-actions *pspace*) :key #'action-name)))
    (sublis (mapcar #'cons (action-parameters action-struct) (cdr action))
	    (case element-type
	      (preconditions (action-preconditions action-struct))
	      (adds (action-adds action-struct))
	      (dels (action-dels action-struct))
	      (effects (append (action-adds action-struct)
			       (mapcar #'(lambda (del) (list 'not del)) (action-dels action-struct))))
	      (t nil))
	    :test #'equal)))

(defun domain-predicates nil
  (let ((preds nil))
    (maphash #'(lambda (key value) (push key preds))
	     (dom-predicates *pspace*))
    preds))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;   Plan merging. It solves each agent problem individually and saves results
;;;;   for later merging those results
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; It solves the problems of the selected agents. It will allow to perform plan merging afterwards
;; I assume agents can run in parallel, and thus time is the max of all agents.
(defun solve-for-merging (domain algorithm timeout probsets-dir domain-dir output-file
			  agents parallel-planning-p)
  (let ((solution nil)
	(init-time (get-internal-real-time))
	(remaining-time timeout)
	(global-solution nil)
	(time 0) (nodes 0) (length 0) (cost 0))
    (with-open-file (ostream output-file :direction :output :if-exists :supersede :if-does-not-exist :create)
      (dolist (agent agents)
	(cond (parallel-planning-p (setq remaining-time timeout)
				   (setq init-time (get-internal-real-time)))
	      (t (setq remaining-time (- timeout (elapsed-time init-time 'real-time)))))
	(setq solution (the-ring algorithm remaining-time domain (agent-domain-file agent) (agent-problem-file agent)
				 :probsets-dir probsets-dir :domain-dir domain-dir))
	(when (and solution (solution-found solution))
	  (if parallel-planning-p (setq time (max time (elapsed-time init-time 'real-time))))
	  (if *trace-ma-sayphi* (format t "~2%Solution: ~a" solution))
	  (setq global-solution (append global-solution (give-me-plan-list solution)))
	  (incf nodes (solution-num-nodes solution))
	  (incf length (solution-length solution))
	  (incf cost (solution-total-cost solution))))
      (say-pp-solution (make-solution :found (and global-solution t)
				      :total-time (if parallel-planning-p time (elapsed-time init-time 'real-time))
				      :length length
				      :path global-solution
				      :num-nodes nodes
				      :total-cost cost)
		       nil ostream t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runs obfuscated centralized (CMAP)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; It returns the obfuscated solution, the obfuscated domain and obfuscated problem
(defun run-cmap (algorithm domain domain-file problem probsets-dir timeout
		 output-file assignment-time validate-obfuscated-p domain-dir parallel-plan-p
		 anytime-p anytime-algorithm search-options init-time plan-file)
  (let ((solution nil)
	(anytime-solution nil)
	(plan nil)
	(makespan 0)
	(parallelization-time 0))
    (free-mem)
    (unless (member algorithm '(lama-first lama-unit-cost lama-second lama-seq lama-opt
					   lpg-adapt cgamer metric-ff cbp-estocastico))
      (say-domain domain *merged-domain* nil)
      (prob (concatenate 'string probsets-dir *merged-problem*) nil))
    (setq solution (the-ring algorithm (- timeout assignment-time) domain *merged-domain* *merged-problem*
			     :probsets-dir probsets-dir :domain-dir domain-dir :search-options search-options))
    (cond ((and solution (solution-found solution) (> (solution-length solution) 0))
	   (when anytime-p
	     (save-solution-plan solution plan-file domain domain-file problem probsets-dir)
	     (setq anytime-solution (the-ring anytime-algorithm (- timeout assignment-time)
					      domain *merged-domain* *merged-problem*
					      :probsets-dir probsets-dir :domain-dir domain-dir
					      :search-options search-options
					      :max-cost (solution-total-cost solution))))
	   (if (and anytime-solution (solution-found anytime-solution) (> (solution-length anytime-solution) 0))
	       (setq solution anytime-solution))
	   (setq plan (des-obfuscate (solution-path solution)))
	   (when (and plan parallel-plan-p)
	     (setq parallelization-time (get-internal-real-time))
	     (setq makespan (+ 1 (caar (last (compute-parallel-plan domain domain-file problem probsets-dir plan t)))))
	     (setq parallelization-time (elapsed-time parallelization-time 'real-time)))
	   (if output-file
	       (with-open-file (ostream output-file :direction :output :if-exists :append :if-does-not-exist :create)
		 (format ostream "~%(CMAP ~a T 1 1 ~,2f ~d ~d ~a ~,2f ~,2f ~,2f ~d)" (pathname-name problem)
			 (elapsed-time init-time 'real-time)
;;			 (+ (solution-total-time solution) assignment-time)
			 (solution-num-nodes solution)
			 (solution-length solution)
			 (if validate-obfuscated-p
			     (validate-sol :solution plan :domain domain :domain-file domain-file
					   :problem-file problem :probsets-dir probsets-dir)
			     'not-validated)
			 assignment-time *preprocessing-time* parallelization-time makespan))
	       (format t "~%Summary CMAP: Problem ~a, Solved: T, Time: ~,2f, Nodes: ~d, Length: ~d, Parallel. time: ~,2f"
		       problem (+ (solution-total-time solution) assignment-time)
		       (solution-num-nodes solution) (solution-length solution) parallelization-time))
	   (setf *solution-cmap* (solution-path solution))
	   (list plan *merged-domain* *merged-problem*))
	  (t (format t "~%  problem not solved.")
	     (if output-file
		 (with-open-file (ostream output-file :direction :output :if-exists :append :if-does-not-exist :create)
		   (format ostream "~%(CMAP ~a nil 0 1 0.0 0 0)" (pathname-name problem))))
	     (setf *solution-cmap* nil)
	     (list nil *merged-domain* *merged-problem*)))))

(defun compute-parallel-plan (domain domain-file problem probsets-dir solution &optional (des-obfuscate-p t))
  (say-domain domain domain-file nil)
  (prob (concatenate 'string probsets-dir problem) nil)
  (build-parallel-plan (if des-obfuscate-p
			   (des-obfuscate (des-obfuscate solution))
			   solution)))

(defun save-solution-plan (solution plan-file domain domain-file problem probsets-dir)
  (with-open-file (ostream plan-file :direction :output :if-exists :supersede :if-does-not-exist :create)
    (say-pp-solution (compute-parallel-plan domain domain-file problem probsets-dir
					    (pddl-to-ma-pddl-solution (if (solution-p solution)
									  (solution-path solution)
									  solution))
					    t)
		     nil ostream t)))


;; In MAPR, there are two levels of substitution
;; In CMAP, there is only one level
;; solution can be a list of actions or T (if all goals are true in the initial state)
;; the MA-PDDL to PDDL compiler could have introduced several new actions, so we have to substitute the new names for
;; the old ones
(defun des-obfuscate (solution &optional (agents *agents*) (only-macros-p nil))
  (if (listp solution)
      (mapcan #'(lambda (one-action)
		  (let* ((sayphi-action-p (snode-p one-action))
			 (action (if sayphi-action-p (snode-plan-action one-action) one-action)))
		    (if (member (car action) *original-actions*)
			(list action)
			(or (some #'(lambda (agent)
				      (des-obfuscate-agent-action agent action agents only-macros-p))
				  agents)
			    (list action)))))
	      solution)
      solution))

;; it is a macro, replace it with its corresponding list of actions
(defun des-obfuscate-agent-action (agent action agents only-macros-p)
  (let ((macro-action (assoc (car action) (agent-macro-operators agent))))
    (cond (macro-action
	   (mapcan #'(lambda (subaction)
		       (or (some #'(lambda (an-agent)
				     (des-obfuscate-agent-action an-agent subaction agents only-macros-p))
				 agents)
			   (list subaction)))
		   (cdr macro-action)))
	  (only-macros-p (list action))
	  (t (let* ((anonymized-action (cdr (assoc (car action) (agent-reverse-anonymize-list agent))))
		    (original-action (if (and anonymized-action (atom anonymized-action))
					 anonymized-action))
		    (stored-params (if original-action
				       (cdr (assoc (car action) (agent-positions-in-actions agent))))))
	       (cond (stored-params
		      (do ((params stored-params (cdr params))
			   (args (cdr action))
			   (new-args nil))
			  ((null params)
			   (list (cons (cdr (assoc (car action) (agent-reverse-anonymize-list agent)))
				       (reverse (sublis (agent-reverse-anonymize-list agent) new-args)))))
			(cond ((listp (car params))
			       (push (car args) new-args)
			       (setq args (cdr args)))
			      (t (push (car params) new-args)))))
		     (anonymized-action (list anonymized-action))
		     (t (some #'(lambda (an-agent)
				  (if (assoc (car action) (agent-macro-operators an-agent))
				      (des-obfuscate-agent-action an-agent action agents only-macros-p)))
			      agents))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runs distributed (MAPR)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; In *solution-mapr*, the solution has been des-obfuscated
(defun run-mapr (domain domain-file problem timeout init-time max-iterations add-goals-p
		 only-one-iteration-p internal-predicates algorithm replanning-algorithm probsets-dir output-file
		 validate-mapr-p assignment-time domain-dir max-planning-iterations parallel-plan-p
		 anytime-p anytime-algorithm search-options use-macros-p only-one-macro-p plan-file)
  (let ((solution nil)
	(complete-plan nil)
	(augmented-solution nil)
	(last-agent nil)
	(solved 0) (total-time 0) (time 0) (nodes 0) (length 0) (cost most-positive-fixnum)
	(parallelization-time 0) (makespan 0) (policyp *policy*)
	(original-solution nil)
	(num-problems (length *agents*)))
    (if (and *trace-ma-sayphi* *policy*) (format t "~%Initial policy: ~a~%" *policy*))
    ;; if it did not find a solution, and it still has time, it repeats from the first agent
    (do* ((iteration 0 (if last-agent-p (1+ iteration) iteration))
	  (init-max-iterations max-iterations)
	  (policy-step 0 (if last-agent-p 0 (1+ policy-step)))
	  (last-agent-p (null *agents*) (if *policy* (null (nthcdr policy-step *policy*)) (null (cdr agents))))
	  (first-iteration-p t (and first-iteration-p (not last-agent-p)))
	  (agents (or *policy* *agents*)
		  (if last-agent-p
		      (or *policy* *agents*)
		      (if *policy* (nthcdr policy-step *policy*) (cdr agents))))
	  (agent (if *policy* (caar agents) (car agents))
		 (if *policy* (caar agents) (car agents)))
	  (problem-file (agent-problem-file agent) (agent-problem-file agent))
	  (previous-agent nil)
	  (previous-problem nil)
	  (improved-solution-p nil) ;; T when it executed anytime-planner
	  (remaining-time (- timeout (elapsed-time init-time 'real-time)) (- timeout (elapsed-time init-time 'real-time)))
	  (last-correct-augmented-solution (list nil 0 0 0 nil nil nil nil nil nil nil most-positive-fixnum 'partial))
	  (timeoutp (<= remaining-time 0.0) (<= remaining-time 0.0)))
	 ((or timeoutp
	      (>= iteration max-iterations)
	      (and (or last-agent-p (and add-goals-p (not first-iteration-p) (not *policy*)))
		   solution
		   (eq (nth 12 augmented-solution) 'total))
	      (and last-agent-p only-one-iteration-p))
	  ;; if it didn't call the anytime planner, it tries it now
	  (when (and anytime-p (not improved-solution-p) solution (eq (nth 12 augmented-solution) 'total) (not timeoutp))
	    (save-solution-plan solution plan-file domain domain-file problem probsets-dir)
	    (setq augmented-solution
		  (call-agent agent domain augmented-solution internal-predicates anytime-algorithm remaining-time
			      probsets-dir add-goals-p domain-dir max-planning-iterations anytime-p cost
			      search-options use-macros-p only-one-macro-p 0))
	    (when (and (nth 0 augmented-solution) (eq (nth 12 augmented-solution) 'total))
	      (setq solution (nth 0 augmented-solution))
	      (setq complete-plan (if add-goals-p solution (append complete-plan solution)))
	      (incf solved)
	      (incf time (nth 1 augmented-solution))
	      (incf nodes (nth 2 augmented-solution))
	      (setq last-agent agent)
	      (if add-goals-p
		  (setq length (nth 3 augmented-solution))
		  (incf length (nth 3 augmented-solution)))
	      (setq cost (nth 11 augmented-solution))))
	  (if (and solution (eq (nth 12 augmented-solution) 'total)
		   (or last-agent-p (and add-goals-p (not first-iteration-p))))
	      (setf *solution-mapr* (des-obfuscate (des-obfuscate complete-plan)))
;; 	      (setf *solution-mapr* (des-obfuscate complete-plan (list last-agent)))
	      (setf *solution-mapr* nil)))
;;      (if last-agent-p (setf *policy* nil))
      (setq last-agent agent)
      (if (and (not first-iteration-p) last-agent-p) (format t "~%Restarting from the first agent"))
      (when *trace-ma-sayphi*
	(format t "~2%***** Agent ~a, policy step ~d. Time ~,2f; remaining total time ~,2f~%"
		agent policy-step remaining-time remaining-time))
      (if (and anytime-p
	       (or (and (null (cdr agents))
			(not first-iteration-p))
		   (>= iteration max-iterations)))
	  (setq improved-solution-p t))
      ;; the cdr of the corresponding item in the policy contains the subgoals the agent has to achieve in this iteration
      (if *policy*
	  (setf (agent-subgoals agent)
		(union (cadr (nth policy-step *policy*)) (caddr (nth policy-step *policy*)) :test #'equal)))
      ;; second iteration or later when it was using a policy in the first iteration. I have to force to work on
      ;; all the public goals
      (if (and policyp (not *policy*)) (setf (nth 9 augmented-solution) *all-public-goals*))
      (setq augmented-solution
	    (call-agent agent domain augmented-solution internal-predicates
			(if improved-solution-p
			    anytime-algorithm
			    (if (car augmented-solution)
				replanning-algorithm
				algorithm))
			remaining-time probsets-dir add-goals-p domain-dir max-planning-iterations
			anytime-p cost search-options
			use-macros-p only-one-macro-p policy-step))
      (setq previous-agent agent)
      (setq previous-problem problem-file)
      (setq solution (nth 0 augmented-solution))
      (if *policy* (setq max-iterations (* init-max-iterations (length *policy*))))
      (cond ((and solution (eq (nth 12 augmented-solution) 'total))
	     (setq last-correct-augmented-solution augmented-solution)
	     (if *trace-ma-sayphi* (format t "~%Partial solution of agent ~a: ~%~a" agent solution))
	     (setq complete-plan (if add-goals-p solution (append complete-plan solution)))
	     (incf solved)
	     (incf time (nth 1 augmented-solution))
	     (incf nodes (nth 2 augmented-solution))
	     (if add-goals-p
		 (setq length (nth 3 augmented-solution))
		 (incf length (nth 3 augmented-solution)))
	     (setq cost (nth 11 augmented-solution))
	     (if *trace-ma-sayphi*
		 (format t "~%Problem: ~a, Solved: T, Time: ~,2f, Nodes: ~d, Length: ~d" problem-file time nodes length)))
	    (t (setf (nth 6 last-correct-augmented-solution) (nth 6 augmented-solution))
	       (setf (nth 4 last-correct-augmented-solution) (nth 4 augmented-solution))
	       (setq cost most-positive-fixnum)
	       (setf (nth 9 last-correct-augmented-solution) (nth 9 augmented-solution))
	       (if *trace-ma-sayphi* (format t "~%Problem: ~a, Solved: NIL" problem-file)))))
    ;; I have to des-obfuscate twice, since in MAPR there are two levels of obfuscation. The first
    ;; generated in the first step and the second one for removing parameters for the next agent
    ;; (des-obfuscate (des-obfuscate *solution-mapr*))))
    (setq original-solution (if (listp *solution-mapr*) *solution-mapr*))
    (when (and original-solution parallel-plan-p)
      (setq parallelization-time (get-internal-real-time))
      (setq makespan (+ 1 (caar (last (compute-parallel-plan domain domain-file problem probsets-dir
							     original-solution t)))))
      (setq parallelization-time (elapsed-time parallelization-time 'real-time)))
    (setq total-time (elapsed-time init-time 'real-time))
    (if (not original-solution) (format t "~%  problem not solved."))
    (if output-file
	(with-open-file (ostream output-file :direction :output :if-exists :append :if-does-not-exist :create)
	  (format ostream "~%(MAPR-~a-~a ~a ~a ~d ~d ~,2f ~d ~d ~a ~,2f ~,2f ~,2f ~d)" algorithm replanning-algorithm
		  (pathname-name problem)
		  (if solution t) solved num-problems total-time nodes (length original-solution)
		  (if (and validate-mapr-p *solution-mapr*)
		      (validate-sol :solution original-solution
				    :domain domain :domain-file domain-file
				    :problem-file problem :probsets-dir probsets-dir)
		      'not-validated)
		  assignment-time *preprocessing-time* parallelization-time makespan))
	(format t
		"~%Summary MAPR: Problem ~a, Solved: ~d/~d, Time: ~,2f, Nodes: ~d, Length: ~d, Total Time: ~,2f, #Agents: ~d, Parallelization-time: ,2f"
		problem solved num-problems time nodes length total-time num-problems parallelization-time))
    ;; if last solution is not nil, it should be a valid plan, since we add goals from one problem to the next
    (if (and solution (or add-goals-p (= solved num-problems)))
	(list complete-plan
	      (agent-mapr-domain-file last-agent)
	      (agent-mapr-problem-file last-agent)))))

;; info-previous-agents is a list of the form (everything instantiated with the external information and the anonymized information of the previous agents
;; (solution-list time nodes length predicates functions constants new-actions state goals)
;; There are two alternatives: pass the previous internal/external goals or not. if not, then we would have to cycle through agents and make sure we do
;; not loop by giving again and again the same solutions and the other agents applying actions that remove those previous goals. if we pass the internal
;; goals, planning takes more time.
;; anytime-p: if T, it will call replanning-algorithm (that comes from anytime-algorithm) with upper bound on cost set
;; as max-cost
;; this function is as ugly as it can be, but there is no easy way to shrink it
(defun call-agent (agent domain info-previous-agents internal-predicates algorithm timeout
		   probsets-dir add-goals-p domain-dir max-planning-iterations anytime-p max-cost search-options
		   use-macros-p only-one-macro-p policy-step)
  (if (and *trace-ma-sayphi* info-previous-agents)
      (format t "~%Communication cost: ~,3f" (elapsed-time *init-communication-time* 'real-time)))
  (let* ((init-time (get-internal-real-time))
	 (actions (nth 7 info-previous-agents))
	 (domain-file (agent-domain-file agent))
	 (domain-def (cdr (read-all-file (concatenate 'string domain-dir domain-file))))
	 (domain-name (car (find-argument domain-def 'domain)))
	 (previous-types (process-types (nth 10 info-previous-agents)))
	 (merged-types (merge-types previous-types (process-types (find-argument domain-def :types))))
	 (new-types (flatten-types merged-types))
	 (predicates (typed-union (nth 4 info-previous-agents) (find-argument domain-def :predicates) merged-types))
	 (functions (typed-union (nth 5 info-previous-agents) (find-argument domain-def :functions) merged-types))
	 (previous-constants (merge-instances (nth 6 info-previous-agents)
					      (process-instances (find-argument domain-def :constants))))
	 (new-constants nil)
	 (new-domain-file (format nil "~(~a~)-mapr.pddl" (pathname-name domain-file)))
	 (problem-file (agent-problem-file agent))
	 (problem-def (cdr (read-all-file (concatenate 'string probsets-dir problem-file))))
	 (new-problem-file (if (pathname-type problem-file)
			       (concatenate 'string (pathname-name problem-file) "-mapr." (pathname-type problem-file))
			       (concatenate 'string (pathname-name problem-file) "-mapr")))
	 (state (union (nth 8 info-previous-agents) (find-argument problem-def :init) :test #'equal))
	 (all-goals (give-me-all-goals problem-def))
	 (subgoals (agent-subgoals agent))
	 (goals-without-subgoals (if *policy*
				     (union (nth 9 info-previous-agents) (agent-assigned-goals agent) :test #'equal)))
	 (goals (if *policy*
		    (union subgoals goals-without-subgoals :test #'equal)
		    (if add-goals-p
			(union (nth 9 info-previous-agents) all-goals :test #'equal)
			all-goals)))
	 (goals-true-in-state (intersection state goals :test #'equal))
	 (all-goals-true-p (null (set-difference goals goals-true-in-state :test #'equal)))
	 (anonymize-list nil)
	 effects agent-solution plan solution predicates-in-plan new-goals)
    (cond ((or info-previous-agents subgoals)
	   (cond (info-previous-agents
		  ;; we have to generate auxiliary domain and problem files that include previous agents solutions
		  (setf (agent-mapr-domain-file agent) new-domain-file)
		  (write-domain-pddl-file domain-name (find-argument domain-def :requirements)
					  new-types
					  predicates functions
					  (union actions (give-me-all-actions domain-def) :test #'equal)
					  (concatenate 'string domain-dir new-domain-file)
					  (flatten-instances previous-constants))
		  (free-mem)
		  (say-domain domain new-domain-file nil))
		 (t (parse-domain domain-def)
		    (setf (agent-mapr-domain-file agent) domain-file)))
	   (setf (agent-mapr-problem-file agent) new-problem-file)
	   (setq new-constants (if info-previous-agents
				   (remove-previous-constants (find-argument problem-def :objects) previous-constants)
				   (find-argument problem-def :objects)))
	   (write-pddl-file (pathname-name new-problem-file) domain-name
			    new-constants state goals
			    (concatenate 'string probsets-dir new-problem-file)
			    (find-argument problem-def :metric)))
	  (t (parse-domain domain-def)
	     (setf (agent-mapr-domain-file agent) domain-file)
	     (setf (agent-mapr-problem-file agent) problem-file)
	     (setq new-problem-file problem-file)))
    ;;    (parse-problem problem-def)
    (prob (concatenate 'string probsets-dir new-problem-file) nil)
    (if (and *trace-ma-sayphi* subgoals) (format t "~%Goals: ~a~%Subgoals: ~a~%Init goals: ~a" goals subgoals all-goals))
    (do ((timeoutp nil)
	 (remaining-time 0)
	 (iterations 0 (1+ iterations))
	 (triedp nil t))
	((or all-goals-true-p
	     (and solution (solution-p solution) (solution-found solution))
	     (>= iterations max-planning-iterations)
	     timeoutp (and triedp (not (eq algorithm 'errtplan)) (not (eq algorithm 'lpg-adapt))))
	 (setf *init-communication-time* (get-internal-real-time))
	 (if all-goals-true-p
	     (setq solution (make-solution :found t
					   :total-time (elapsed-time init-time 'real-time)
					   :length 0
					   :path nil
					   :num-nodes 0
					   :total-cost 0))))
      (setq remaining-time (- timeout (elapsed-time init-time 'real-time)))
      (if *trace-ma-sayphi* (format t "~%Remaining time for repeated execution: ~,2f" remaining-time))
      (if (> remaining-time 0)
	  (setq solution (the-ring algorithm timeout
				   domain (if info-previous-agents new-domain-file domain-file) new-problem-file
				   :previous-solution (nth 0 info-previous-agents)
				   :probsets-dir probsets-dir :domain-dir domain-dir
				   :search-options search-options :max-cost (if anytime-p max-cost)))
	  (setq timeoutp t))
      (setq remaining-time (- timeout (elapsed-time init-time 'real-time)))
      (if (and *policy* (or (not solution) (not (solution-p solution)) (not (solution-found solution))))
	  (if (> remaining-time 0)
	      (setq solution
		    (second-try remaining-time policy-step
				(union (cadr (nth policy-step *policy*)) goals-without-subgoals :test #'equal)
				new-problem-file domain-name new-constants
				state probsets-dir problem-def algorithm domain info-previous-agents
				new-domain-file domain-file search-options anytime-p max-cost domain-dir))
	      (setq timeoutp t))))
;;    (if subgoals (setq goals (union (nth 9 info-previous-agents) (set-difference all-goals subgoals :test #'equal)
;; :test #'equal)))
    (setf *union-preconds* nil)
    (setf *union-effects* nil)
    (setf *union-costs* nil)
    (setf *plan-constants* nil)
    ;;     (setf *macro-ops* nil)
    (setq plan (give-me-plan-list solution))
    (setq agent-solution (agent-solution plan agent use-macros-p only-one-macro-p internal-predicates))
    (setq actions (remove-if #'(lambda (action)
				 (or (member (cadr action) *original-actions*)
				     (not (member (cadr action) agent-solution :key #'caar))))
			     actions))
    (dolist (augmented-action agent-solution)
      (unless (member (caar augmented-action) *original-actions*)
	(setq effects (append (nth 2 augmented-action) (nth 4 augmented-action)))
	(dolist (del (nth 3 augmented-action))
	  (push (list 'not del) effects))
	(pushnew `(:action ,(caar augmented-action) :parameters ()
			   :precondition (and ,@(cadr augmented-action)) :effect (and ,@effects))
		 actions :test #'equal)))
    (setq anonymize-list (agent-anonymize-list agent))
    (setq new-goals (if *policy* goals-without-subgoals goals))
;;     (setf *policy* (sublis anonymize-list *policy* :test #'equal))
    (setq predicates-in-plan (union *union-preconds* *union-effects* :test #'equal))
    (if (and *trace-ma-sayphi* *policy*) (format t "~%New achievable by: ~a~%New policy: ~a~%" *achievable-by* *policy*))
    (dolist (goal new-goals)
      (dolist (arg (cdr goal))
	(pushnew (cons (get-object-type arg) arg)
		 *plan-constants* :key #'cdr)))
    (if (and solution (solution-found solution))
	;; if there was a trivial solution (all goals true in state), it returns a T in the solution
	(list (if agent-solution (mapcar #'car agent-solution) t)
	      (solution-total-time solution) (solution-num-nodes solution) (solution-length solution)
	      (remove-irrelevant-defs predicates (union predicates-in-plan new-goals :test #'equal)
				      anonymize-list (nth 4 info-previous-agents) t)
	      (remove-irrelevant-defs functions predicates-in-plan anonymize-list (nth 5 info-previous-agents) nil)
	      (join-constants previous-constants *plan-constants* merged-types)
	      actions
;;;; IMPORTANT: REMOVE PRECONDS THAT ARE ADDED BY SOME OTHER ACTION
	      (union goals-true-in-state
		     (intersection *union-preconds* state :test #'equal)
		     :test #'equal)
	      new-goals new-types (solution-total-cost solution) 'total)
	(list (nth 0 info-previous-agents) 0 0 0 predicates ;; (remove-irrelevant-defs predicates new-goals anonymize-list (nth 4 info-previous-agents))
	      (nth 5 info-previous-agents)
	      (join-constants (nth 6 info-previous-agents) *plan-constants* merged-types)
	      (nth 7 info-previous-agents) (nth 8 info-previous-agents)
	      (if add-goals-p new-goals) (nth 10 info-previous-agents) most-positive-fixnum 'partial))))

;; (defun call-agent (agent domain info-previous-agents internal-predicates algorithm timeout
;; 		   probsets-dir add-goals-p domain-dir max-planning-iterations anytime-p max-cost search-options
;; 		   use-macros-p only-one-macro-p)
;;   (if (and *trace-ma-sayphi* info-previous-agents)
;;       (format t "~%Communication cost: ~,3f" (elapsed-time *init-communication-time* 'real-time)))
;;   (let* ((init-time (get-internal-real-time))
;; 	 (agent-reverse-anonymize-list (agent-reverse-anonymize-list agent))
;; 	 (actions (remove-if #'(lambda (action) (assoc (cadr action) agent-reverse-anonymize-list))
;; 			     (nth 7 info-previous-agents)))
;; 	 (domain-file (agent-domain-file agent))
;; 	 (domain-def (cdr (read-all-file (concatenate 'string domain-dir domain-file))))
;; 	 (domain-name (car (find-argument domain-def 'domain)))
;; 	 (previous-types (process-types (nth 10 info-previous-agents)))
;; 	 (merged-types (merge-types previous-types (process-types (find-argument domain-def :types))))
;; 	 (new-types (flatten-types merged-types))
;; 	 (predicates (union (nth 4 info-previous-agents) (find-argument domain-def :predicates) :test #'equal))
;; 	 (functions (union (nth 5 info-previous-agents) (find-argument domain-def :functions) :test #'equal))
;; 	 (previous-constants (merge-instances (nth 6 info-previous-agents)
;; 					      (process-instances (find-argument domain-def :constants))))
;; 	 (new-domain-file (format nil "~(~a~)-mapr.pddl" (pathname-name domain-file)))
;; 	 (problem-file (agent-problem-file agent))
;; 	 (problem-def (cdr (read-all-file (concatenate 'string probsets-dir problem-file))))
;; 	 (new-problem-file (if (pathname-type problem-file)
;; 			       (concatenate 'string (pathname-name problem-file) "-mapr." (pathname-type problem-file))
;; 			       (concatenate 'string (pathname-name problem-file) "-mapr")))
;; 	 (state (union (nth 8 info-previous-agents) (find-argument problem-def :init) :test #'equal))
;; 	 (all-goals (give-me-all-goals problem-def))
;; 	 (subgoals (agent-subgoals agent))
;;  	 (previous-subgoals (nth 13 info-previous-agents))
;; 	 (goals (if add-goals-p
;; 		    (union (nth 9 info-previous-agents) all-goals :test #'equal)
;; 		    all-goals))
;; 	 (goals-true-in-state (intersection state goals :test #'equal))
;; 	 (all-goals-true-p (null (set-difference goals goals-true-in-state :test #'equal)))
;; 	 (anonymize-list nil)
;; 	 constants effects agent-solution plan solution result predicates-in-plan new-goals new-problem-def reachable-subgoals)
;;     (cond ((or info-previous-agents subgoals)
;; 	   (cond (info-previous-agents
;; 		  ;; we have to generate auxiliary domain and problem files that include previous agents solutions
;; 		  (setf (agent-mapr-domain-file agent) new-domain-file)
;; 		  (write-domain-pddl-file domain-name (find-argument domain-def :requirements)
;; 					  new-types
;; 					  predicates functions
;; 					  (append actions (give-me-all-actions domain-def))
;; 					  (concatenate 'string domain-dir new-domain-file)
;; 					  (flatten-instances previous-constants))
;; 		  (free-mem)
;; 		  (say-domain domain new-domain-file nil))
;; 		 (t (parse-domain domain-def)
;; 		    (setf (agent-mapr-domain-file agent) domain-file)))
;; 	   (setf (agent-mapr-problem-file agent) new-problem-file)
;; 	   (write-pddl-file (pathname-name new-problem-file) domain-name
;; 			    (if info-previous-agents
;; 				(remove-previous-constants (find-argument problem-def :objects) previous-constants)
;; 				(find-argument problem-def :objects))
;; 			    state goals
;; 			    (concatenate 'string probsets-dir new-problem-file)
;; 			    (find-argument problem-def :metric))
;; 	   (cond (subgoals
;; 		  (setq new-problem-def (cdr (read-all-file (concatenate 'string probsets-dir new-problem-file))))
;; 		  (parse-problem new-problem-def)
;; 		  (set-duplicate-hashing)
;; 		  (setq i-node (initialize-current-problem))
;; 		  ;; (setq new-goals (union goals subgoals :test #'equal))
;; 		  (if *trace-ma-sayphi* (format t "~%Trying for rechability subgoals: ~a~%  and goals: ~a" subgoals goals))
;; 		  (dolist (subgoal subgoals)
;; 		    (setf (problem-goals *current-problem*) (literalgoals-bitmap (list subgoals)))
;; 		    (if (< (h-metric-rxplan i-node) most-positive-fixnum)
;; 			(push subgoal reachable-subgoals)))
;; 		  (setq subgoals (compute-new-subgoals previous-subgoals reachable-subgoals))
;; 		  (if *trace-ma-sayphi* (format t "~%Subgoals that can be reached: ~a~%New subgoals: ~a" reachable-subgoals subgoals))
;; 		  (cond (reachable-subgoals
;; 			 (setq goals (union goals reachable-subgoals :test #'equal))
;; 			 (setq goals-true-in-state (intersection state goals :test #'equal))
;; 			 (setq all-goals-true-p (null (set-difference goals goals-true-in-state :test #'equal)))
;; 			 (write-pddl-file (pathname-name new-problem-file) domain-name
;; 					  (find-argument new-problem-def :objects)
;; 					  state goals
;; 					  (concatenate 'string probsets-dir new-problem-file)
;; 					  (find-argument problem-def :metric)))
;; 			(t (setq subgoals previous-subgoals))))
;; 		 (t (setq subgoals previous-subgoals))))
;; 	  (t (parse-domain domain-def)
;; 	     (setf (agent-mapr-domain-file agent) domain-file)
;; 	     (setf (agent-mapr-problem-file agent) problem-file)
;; 	     (setq new-problem-file problem-file)))
;;     ;;    (parse-problem problem-def)
;;     (prob (concatenate 'string probsets-dir new-problem-file) nil)
;;     (if (and *trace-ma-sayphi* subgoals)
;; 	(format t "~%Trying ~a execution with~%Goals: ~a~%Subgoals: ~a~%Init goals: ~a" agent goals subgoals all-goals))
;;     (do ((timeoutp nil)
;; 	 (remaining-time 0)
;; 	 (iterations 0 (1+ iterations))
;; 	 (triedp nil t))
;; 	((or all-goals-true-p
;; 	     (and solution (solution-p solution) (solution-found solution))
;; 	     (>= iterations max-planning-iterations)
;; 	     timeoutp (and triedp (not (eq algorithm 'errtplan)) (not (eq algorithm 'lpg-adapt))))
;; 	 (setf *init-communication-time* (get-internal-real-time))
;; 	 (if all-goals-true-p
;; 	     (setq solution (make-solution :found t
;; 					   :total-time (elapsed-time init-time 'real-time)
;; 					   :length 0
;; 					   :path nil
;; 					   :num-nodes 0
;; 					   :total-cost 0))))
;;       (setq remaining-time (- timeout (elapsed-time init-time 'real-time)))
;;       (if *trace-ma-sayphi* (format t "~%Remaining time for repeated execution: ~,2f" remaining-time))
;;       (if (> remaining-time 0)
;; 	  (setq solution (the-ring algorithm timeout
;; 				   domain (if info-previous-agents new-domain-file domain-file) new-problem-file
;; 				   :previous-solution (nth 0 info-previous-agents)
;; 				   :probsets-dir probsets-dir :domain-dir domain-dir
;; 				   :search-options search-options :max-cost (if anytime-p max-cost)))
;; 	  (setq timeoutp t))
;;       ;; if it solved the problem with subgoals, it removes the subgoals from the list of subgoals of the agent
;;       ;; otherwise, it tries again with the reachable-subgoals
;;       (when subgoals
;; 	(setq remaining-time (- timeout (elapsed-time init-time 'real-time)))
;; 	(cond ((and (or (not solution) (not (solution-p solution)) (not (solution-found solution)))
;; 		    (>= remaining-time 0))
;; 	       (if *trace-ma-sayphi* (format t "~%Repeating execution without subgoals~%New goals: ~a" goals))
;; 	       (write-pddl-file (pathname-name new-problem-file) domain-name
;; 				(find-argument new-problem-def :objects)
;; 				state reachable-subgoals
;; 				(concatenate 'string probsets-dir new-problem-file)
;; 				(find-argument problem-def :metric))
;; 	       (prob (concatenate 'string probsets-dir new-problem-file) nil)
;; 	       (setq solution (the-ring algorithm timeout
;; 					domain (if info-previous-agents new-domain-file domain-file) new-problem-file
;; 					:previous-solution (nth 0 info-previous-agents)
;; 					:probsets-dir probsets-dir :domain-dir domain-dir
;; 					:search-options search-options :max-cost (if anytime-p max-cost))))
;; 	      ((<= remaining-time 0) (setq timeoutp t))
;; 	      (t (setf (agent-subgoals agent) (set-difference (agent-subgoals agent) reachable-subgoals :test #'equal))))
;; 	(setq goals (set-difference goals reachable-subgoals :test #'equal))))
;;     (setf *union-preconds* nil)
;;     (setf *union-effects* nil)
;;     (setf *union-costs* nil)
;;     (setf *plan-constants* nil)
;;     ;;     (setf *macro-ops* nil)
;;     (setq plan (give-me-plan-list solution))
;;     (setq agent-solution (agent-solution plan agent state use-macros-p only-one-macro-p internal-predicates merged-types))
;;     (setq actions (remove-if #'(lambda (action)
;; 				 (or (member (cadr action) *original-actions*)
;; 				     (not (member (cadr action) agent-solution :key #'caar))))
;; 			     actions))
;;     (dolist (augmented-action agent-solution)
;;       (unless (member (caar augmented-action) *original-actions*)
;; 	(setq effects (append (nth 2 augmented-action) (nth 4 augmented-action)))
;; 	(dolist (del (nth 3 augmented-action))
;; 	  (push (list 'not del) effects))
;; 	(pushnew `(:action ,(caar augmented-action) :parameters ()
;; 			   :precondition (and ,@(cadr augmented-action)) :effect (and ,@effects))
;; 		 actions :test #'equal)))
;;     (setq anonymize-list (agent-anonymize-list agent))
;;     (setq new-goals (sublis anonymize-list goals :test #'equal))
;;     (setq predicates-in-plan (union *union-preconds* *union-effects* :test #'equal))
;;     (dolist (goal new-goals)
;;       (dolist (arg (cdr goal))
;; 	(pushnew (cons (get-object-type arg) arg)
;; 		 *plan-constants* :key #'cdr)))
;;     (if (and solution (solution-found solution))
;; 	;; if there was a trivial solution (all goals true in state), it returns a T in the solution
;; 	(list (if agent-solution (mapcar #'car agent-solution) t)
;; 	      (solution-total-time solution) (solution-num-nodes solution) (solution-length solution)
;; 	      (remove-irrelevant-defs predicates (union predicates-in-plan new-goals :test #'equal)
;; 				      anonymize-list (nth 4 info-previous-agents) t)
;; 	      (remove-irrelevant-defs functions predicates-in-plan anonymize-list (nth 5 info-previous-agents) nil)
;; 	      (join-constants previous-constants *plan-constants* merged-types)
;; 	      actions
;; ;;;; IMPORTANT: REMOVE PRECONDS THAT ARE ADDED BY SOME OTHER ACTION
;; 	      (union (sublis anonymize-list goals-true-in-state :test #'equal)
;; 		     (intersection *union-preconds* (sublis anonymize-list state :test #'equal) :test #'equal)
;; 		     :test #'equal)
;; 	      new-goals new-types (solution-total-cost solution) 'total subgoals)
;; 	(list (nth 0 info-previous-agents) 0 0 0 predicates ;; (remove-irrelevant-defs predicates new-goals anonymize-list (nth 4 info-previous-agents))
;; 	      (nth 5 info-previous-agents)
;; 	      (join-constants (nth 6 info-previous-agents) *plan-constants* merged-types)
;; 	      (nth 7 info-previous-agents) (nth 8 info-previous-agents)
;; 	      (if add-goals-p new-goals) (nth 10 info-previous-agents) most-positive-fixnum 'partial subgoals))))
    ;; DEBERIA QUITAR TAMBIEN LOS PREDICADOS/FUNCIONES ANONIMOS QUE NO UTILIZA NINGUNA ACCION EN EL PLAN.
    ;; TAMBIEN DEBO QUITAR LAS ACCIONES QUE SE QUEDAN SOLO CON PREDICADOS ANONIMOS?

(defun second-try (remaining-time policy-step goals new-problem-file domain-name new-constants
		   state probsets-dir problem-def algorithm domain info-previous-agents
		   new-domain-file domain-file search-options anytime-p max-cost domain-dir)
  (let ((agent (car (nth policy-step *policy*)))
	solution responsible-agent second-solution new-goals saved-solution)
    (if *trace-ma-sayphi* (format t "~2%Repeating execution only with goals of next agent~%New goals: ~a" goals))
    (write-pddl-file (pathname-name new-problem-file) domain-name new-constants state goals
		     (concatenate 'string probsets-dir new-problem-file)
		     (find-argument problem-def :metric))
    (prob (concatenate 'string probsets-dir new-problem-file) nil)
    (setq solution (the-ring algorithm remaining-time
			     domain (if info-previous-agents new-domain-file domain-file) new-problem-file
			     :previous-solution (nth 0 info-previous-agents)
			     :probsets-dir probsets-dir :domain-dir domain-dir
			     :search-options search-options :max-cost (if anytime-p max-cost)))
;;     (if *trace-ma-sayphi* (format t "~%Solution: ~a" (give-me-plan-list (solution-path solution))))
    (when (and solution (solution-p solution) (solution-found solution))
      (setq new-goals goals)
      (dolist (diff-goal (caddr (nth policy-step *policy*)))
	;; greedy search of maximum set of achievable goals
	(setq new-goals (cons diff-goal new-goals))
	(if *trace-ma-sayphi* (format t "~%Checking for solution to goal ~a~%  with goals ~a" diff-goal new-goals))
	(write-pddl-file (pathname-name new-problem-file) domain-name new-constants state new-goals
			 (concatenate 'string probsets-dir new-problem-file)
			 (find-argument problem-def :metric))
	(setq second-solution (the-ring algorithm remaining-time
					domain (if info-previous-agents new-domain-file domain-file) new-problem-file
					:previous-solution (nth 0 info-previous-agents)
					:probsets-dir probsets-dir :domain-dir domain-dir
					:search-options search-options :max-cost (if anytime-p max-cost)))
;; 	(if *trace-ma-sayphi* (format t "~%Solution: ~a" (give-me-plan-list (solution-path second-solution))))
	(cond ((and second-solution (solution-p second-solution) (solution-found second-solution))
	       (setq saved-solution second-solution)
	       (pushnew diff-goal (cdr (assoc agent *achievable-by*)) :test #'equal)
	       (if *trace-ma-sayphi* (format t "~% ... and the current agent can re-achieve it" diff-goal)))
	      (t (setq new-goals (cdr new-goals))
		 (setq responsible-agent (some #'(lambda (agent-goals)
						   (if (member diff-goal (cdr agent-goals) :test #'equal)
						       (car agent-goals)))
					       *achievable-by*))
		 (setf (caddr (nth policy-step *policy*))
		       (remove diff-goal (caddr (nth policy-step *policy*)) :test #'equal))
		 (if *trace-ma-sayphi*
		     (format t "~% ... and the current agent cannot re-achieve it.~%Agent that can re-achieve it: ~a" 
			     (or responsible-agent agent)))
		 ;; if responsible-agent=NIL, then we assume the current agent was responsible to make it true,
		 ;; so we add it to the policy. I am not sure whether I should also add it to *achievable-by*
		 (insert-in-position diff-goal (or responsible-agent agent) policy-step)))))
    (setq solution (if (and saved-solution (solution-p saved-solution) (solution-found saved-solution))
		       saved-solution
		       solution))
;;     (if *trace-ma-sayphi* (format t "~%Solution second try: ~a" (give-me-plan-list (solution-path solution))))
    solution))

(defun insert-in-position (goal agent policy-step)
  (let* ((new-policy nil)
	 (position (or (position-if #'(lambda (step) (member goal (nth 3 step) :test #'equal))
				    *policy* :start (+ 2 policy-step))
		       (1- (length *policy*))))
	 (repeated-agent-p (eq agent (car (nth position *policy*)))))
    (if *trace-ma-sayphi* (format t "~%Inserting agent ~a for goal ~a in policy position ~d" agent goal position))
    (dotimes (i position)
      ;; removes this goal from the following lists until it will add it
      (if (> i policy-step)
	  (setf (caddr (nth i *policy*)) (remove goal (caddr (nth i *policy*)) :test #'equal)))
      (push (nth i *policy*) new-policy))
    ;; for the following iterations
    (cond (repeated-agent-p
	   (push (list agent (if (member goal (cadr (nth position *policy*)) :test #'equal)
				 (cadr (nth position *policy*))
				 (cons goal (cadr (nth position *policy*))))
		       (cadr (nth position *policy*)) (cadr (nth position *policy*)))
		 new-policy))
	  (t (push (list agent (cond ((member goal (cadr (nth (1- position) *policy*)) :test #'equal)
				      (setf (cadar new-policy) (remove goal (cadar new-policy) :test #'equal))
				      (cons goal (cadr (nth (1- position) *policy*))))
				     (t (cons goal (cadr (nth (1- position) *policy*)))))
			 (caddr (nth (1- position) *policy*))
			 (cadddr (nth (1- position) *policy*)))
		   new-policy)))
    (setf *policy* (append (reverse new-policy) (nthcdr position *policy*)))
    (if *trace-ma-sayphi* (format t "~%New policy: ~a" *policy*))))

;; Generates a solution list augmented with preconds, effects and typed parameters.
;; It also removes internal predicates
;; It takes a solution from an agent and generates an external version of the solution for other agents
;; solution can be either a Sayphi structure or a list
;; it requires to have the domain loaded through Sayphi
;; it returns a list of the form:
;; ;; ((action1 external-preconds1 external-adds1 external-dels1 constants-defs) ...)
;; As a side effect, it computes the union of all preconds, so that we can compute its intersection with the state in
;; order to pass it anonymized to the following agents
(defun agent-solution (solution agent use-macros-p only-one-macro-p original-internal-predicates)
  (do* ((steps solution (cdr steps))
	(step (car steps) (car steps))
	(action-step nil nil)
	(result nil)
	(internal-predicates (append (mapcar #'car (agent-reverse-anonymize-list agent))
				     (agent-static-predicates agent)
				     original-internal-predicates))
	(macro-op nil))
       ((or only-one-macro-p (null steps))
	(cond (only-one-macro-p
	       (when solution
		 (setq action-step (learn-macro solution))
		 (setf (cadr action-step) (intern (format nil "~:@(~a-~a~)" (cadr action-step) (agent-name agent))))
		 (if *trace-ma-sayphi* (format t "~%Macro ~a composed of:~%~a" (cadr action-step) solution))
		 (push (cons (cadr action-step) solution) (agent-macro-operators agent))
		 (setq action-step (agent-step action-step agent))
		 (if action-step (list action-step))))
	      (t (reverse result))))
    (cond (use-macros-p
	   (cond ((and (cdr steps) (completely-private-action-p step internal-predicates))
		  (push step macro-op))
		 (macro-op
		  (push step macro-op)
		  (setq macro-op (reverse macro-op))
		  (setq action-step (learn-macro macro-op))
		  (setf (cadr action-step) (intern (format nil "~:@(~a-~a~)" (cadr action-step) (agent-name agent))))
		  (if *trace-ma-sayphi* (format t "~%Macro ~a composed of:~%~a" (cadr action-step) solution))
		  (push (cons (cadr action-step) macro-op) (agent-macro-operators agent))
		  (setq action-step (agent-step action-step agent))
		  (if action-step (push action-step result))
		  (setq macro-op nil))
		 (t (setq action-step (agent-step step agent))
		    (if action-step (push action-step result)))))
	  (t (setq action-step (agent-step step agent))
	     (if action-step (push action-step result))))))
;;		  (push action-step *macro-ops*)
;;   (mapcan #'(lambda (step)
;; 	      (let ((action-step (agent-step step agent state)))
;; 		(if action-step
;; 		    (list action-step))))
;; 	  solution))

(defun completely-private-action-p (plan-step internal-predicates)
  (let* ((action (if (snode-p plan-step)
		     (snode-plan-action plan-step)
		     plan-step))
	 (action-name (car action))
	 (action-struct (find action-name (dom-actions *pspace*) :key #'action-name)))
    (if action-struct
	(and (completely-private-literals-p (action-preconditions action-struct) internal-predicates)
	     (completely-private-literals-p (action-adds action-struct) internal-predicates)
	     (completely-private-literals-p (action-dels action-struct) internal-predicates)))))

(defun completely-private-literals-p (exp internal-predicates)
  (case (car exp)
    ((and or) (completely-private-literals-p (cdr exp) internal-predicates))
    (not (completely-private-literals-p (cadr exp) internal-predicates))
    ((increase assign <= >= + * - / < > when)
     (and (completely-private-literals-p (cadr exp) internal-predicates)
	  (completely-private-literals-p (caddr exp) internal-predicates)))
    ((forall exists) (completely-private-literals-p (caddr exp) internal-predicates))
    (otherwise ;; I hope list of literals or individual literal
     (cond ((listp (car exp))
	    (every #'(lambda (literal) (completely-private-literals-p literal internal-predicates)) exp))
	   ((eq (car exp) '=) t)
	   (t (member (car exp) internal-predicates))))))

;; plan-step might be an (action arg1 ... argn) or the definition of an action (e.g. a recently learned macro)
;; I will have to work out why sometimes action-name is not part of the domain actions
;; state is needed to get rid of static predicates in action
(defun agent-step (plan-step agent)
  (let* ((action (if (snode-p plan-step)
		     (snode-plan-action plan-step)
		     plan-step))
	 (action-def-p (eq (car action) :action))
	 (action-name (if action-def-p (cadr action) (car action)))
	 (action-struct (if action-def-p action-def-p (find action-name (dom-actions *pspace*) :key #'action-name))))
    ;; if it is an external action (it does not have any parameter of a type in agent-types), I will not include it in
    ;; the actions that will be sent to the next agents
    (setf *anonymize-alist* nil)
    (if action-struct
	(let* ((parameters (if action-def-p (nth 3 action) (action-parameters action-struct)))
	       (negated-preds (dom-negative-preds *pspace*))
 	       (substitution (if action-def-p *macro-substitution* (mapcar #'cons parameters (cdr action))))
	       (anonymize-list (agent-anonymize-list agent))
	       (preconds (external-exp (if action-def-p
					   (if (eq (car (nth 5 action)) 'and) (cdr (nth 5 action)) (nth 5 action))
					   (action-preconditions action-struct))
				       substitution anonymize-list t negated-preds
				       (agent-static-predicates agent)))
	       (effects (if action-def-p (nth 7 action)))
	       (only-effects (if (and effects (eq (car effects) 'and)) (cdr effects)))
	       (adds (external-exp (if action-def-p
				       (remove-if #'(lambda (eff) (eq (car eff) 'not)) only-effects)
				       (action-adds action-struct))
				   substitution anonymize-list nil negated-preds
				   (agent-static-predicates agent)))
	       (dels (external-exp (if action-def-p
				       (mapcan #'(lambda (eff) (if (eq (car eff) 'not) (cdr eff))) only-effects)
				       (action-dels action-struct))
				   substitution anonymize-list nil negated-preds
				   (agent-static-predicates agent)))
	       (costs (if (not action-def-p)
			  (external-exp (action-costs action-struct) substitution anonymize-list nil negated-preds
					(agent-static-predicates agent))))
	       (original-agent-action (if action-def-p nil (assoc action-name (agent-positions-in-actions agent))))
	       (new-action-name (if original-agent-action
				    ;; it is an anonymized action from the original set of actions: it has parameters
				    ;; then, it generates a second level of substitution, so we will have to apply sublis
				    ;; twice when des-obfuscating
				    (anonymize-name (intern (format nil "~:@(~{~a~^-~}~)" action)) nil t)
				    action-name)))
	  (dolist (subs *anonymize-alist*)
	    (pushnew (cons (cdr subs) (car subs)) (agent-reverse-anonymize-list agent) :test #'equal)
	    (pushnew subs (agent-anonymize-list agent) :test #'equal))
	  (if original-agent-action
	      (pushnew (cons new-action-name action) (agent-reverse-anonymize-list agent)))
	  (dolist (del dels)
	    ;; in some cases, given how Sayphi stores literals in negated preconditions, an add of a negated literal
	    ;; would result through my code in a (not literal), and then the call-agent function would add another (not
	    ;; (not literal)). I get rid of these cases here
	    (when (eq (car del) 'not)
	      (setq dels (remove del dels :test #'equal))
	      (pushnew (cadr del) adds :test #'equal)))
	  (list (cons new-action-name
		      (if (member action-name *original-actions*)
			  (cdr action)))
		preconds adds dels costs)))))
;;	  (collect-plan-constants (if action-def-p parameters (cdr action)) substitution action-def-p types)
;; 	  (list (cons new-action-name
;; 		      (if (member action-name *original-actions*)
;; 			  (cdr action)
;; 			  (if action-def-p (reverse constants))))
;; 		preconds adds dels costs)

(defun collect-plan-constants (parameters substitution action-def-p types)
  (do ((vars parameters (if action-def-p (cdddr vars) (cdr vars)))
       (new-obj nil)
       (type nil)
       (arguments nil)
       (previous-constant-def nil)
       (common-subtype nil))
      ((null vars)
       arguments)
    (setq new-obj (sublis substitution (car vars)))
    (pushnew new-obj arguments)
    (setq previous-constant-def (find-if #'(lambda (constant-def) (eq new-obj (cdr constant-def))) *plan-constants*))
    (setq type (get-object-type new-obj))
;;     (setq type (if action-def-p (caddr vars) (get-object-type (car vars))))
    (cond (previous-constant-def
	   (setq common-subtype (find-common-subtype (car previous-constant-def) type types))
	   (unless (eq common-subtype (car previous-constant-def))
	     (setf *plan-constants* (remove previous-constant-def *plan-constants* :test #'equal))
	     (push (cons common-subtype new-obj) *plan-constants*)))
	  (t (push (cons type new-obj) *plan-constants*)))))
;; (defun collect-plan-constants (parameters substitution action-def-p action types)
;;   (format t "~%Plan constants: ~a" *plan-constants*)
;;   (if action-def-p
;;       (do ((vars parameters (cdddr vars))
;; 	   (new-obj nil)
;; 	   (arguments nil)
;; 	   (previous-constant-def nil)
;; 	   (common-subtype nil))
;; 	  ((null vars) (format t "~%Plan constants: ~a" *plan-constants*) arguments)
;; 	(setq new-obj (sublis substitution (car vars)))
;; 	(pushnew new-obj arguments)
;; 	(setq previous-constant-def (member new-obj *plan-constants* :key #'cdr))
;; 	(cond (previous-constant-def
;; 	       (setq common-subtype (find-common-subtype (caar previous-constant-def) (caddr vars) types))
;; 	       (unless (eq common-subtype (caar previous-constant-def))
;; 		 (setf *plan-constants* (remove (car previous-constant-def) *plan-constants* :test #'equal))
;; 		 (push (cons common-subtype new-obj) *plan-constants*)))

;; 	      (t (push (cons (caddr vars) new-obj) *plan-constants*))))
;;       (mapc #'(lambda (action-constant)
;; 		(pushnew (cons (get-object-type action-constant)
;; 			       (sublis substitution action-constant))
;; 			 *plan-constants* :test #'equal)
;; 		(format t "~%Plan constants: ~a" *plan-constants*))
;; 	    (cdr action))))

;;; I cannot remove literals, since it would apply any action in almost any order. i have to substitute the internal
;;; predicates for dummy names all over and add the internal initial state of an agent into the initial state of the
;;; next one, again substituting the real predicates and args for dummies

;;; It takes an expression (precond or effect) and substitutes anonymous-internal-predicates-alist
;; anonymous-internal-instances-alist for their gensym equivalents
;; if precondsp=t, it adds the individual literals to the *union-preconds* list
(defun external-exp (exp substitution anonymize-list precondsp negated-preds static-preds)
  (if exp
      (if (atom exp)
	  exp
	  (case (car exp)
	    (and (do* ((preconds (cdr exp) (cdr preconds))
		       (precond (car preconds) (car preconds))
		       (result nil)
		       (intermediate-result (external-exp precond substitution anonymize-list precondsp
							  negated-preds static-preds)
					    (if precond
						(external-exp precond substitution anonymize-list precondsp
							      negated-preds static-preds))))
		      ((or (null preconds) (null intermediate-result))
		       (if (and (null preconds) result)
			   (cons 'and (reverse result))))
		   (if (consp intermediate-result)
		       (push intermediate-result result))))
	    (or (do* ((preconds (cdr exp) (cdr preconds))
		      (precond (car preconds) (car preconds))
		      (result nil)
		      (intermediate-result (external-exp precond substitution anonymize-list precondsp
							 negated-preds static-preds)
					   (if precond
					       (external-exp precond substitution anonymize-list precondsp
							     negated-preds static-preds))))
		     ((or (null preconds) (eq intermediate-result t))
		      (if (and (null preconds) result)
			  (cons 'or (reverse result))
			  t))
		  (if (consp intermediate-result)
		      (push intermediate-result result))))
	    (not (let ((result (external-exp (cadr exp) substitution anonymize-list precondsp negated-preds static-preds)))
		   (if (consp result)
		       (cons 'not (list result))
		       ;; static predicate
		       (not result))))
	    ((increase assign <= >= + * - / < > when)
	     (let ((result1 (external-exp (cadr exp) substitution anonymize-list precondsp negated-preds static-preds))
		   (result2 nil))
	       (when result1
		 (setq result2 (external-exp (caddr exp) substitution anonymize-list precondsp negated-preds static-preds))
		 (when result2
		   (if (not (eq exp 'when)) (pushnew (car result1) *union-costs*))
		   (if (and (listp result2)
			    (not (member (car result2) '(+ * - / when))))
		       (pushnew (car result2) *union-costs*))
		   (list (car exp) result1 result2)))))
	    ((forall exists) (format t "~%Warning: I am not anonymizing yet foralls or exists")
	     (let ((result1 (external-exp (caddr exp) substitution anonymize-list precondsp negated-preds static-preds)))
	       (when result1
		 (list (car exp) (cadr exp) result1))))
	    (otherwise ;; I hope list of literals or individual literal
	     (if (listp (car exp)) ;; this is the same as the case of an and
		 (do* ((preconds exp (cdr preconds))
		       (precond (car preconds) (car preconds))
		       (result nil)
		       (intermediate-result (external-exp precond substitution anonymize-list precondsp
							  negated-preds static-preds)
					    (if precond (external-exp precond substitution anonymize-list precondsp
								      negated-preds static-preds))))
		      ((or (null preconds) (not intermediate-result))
		       (if (null preconds)
			   (if (consp result)
			       (reverse result)
			       result)))
		   (if (consp intermediate-result)
		       (push intermediate-result result)))
		 ;; single literal
		 (let* ((result (sublis substitution exp :test #'equal))
			(negated-pred (negated-pred (car exp) negated-preds))
			(real-pred (cons (or negated-pred (car exp)) (cdr result))))
		   (cond ((and precondsp (member (car real-pred) static-preds)) t)
			 (t 
			  ;; Sayphi converts internally (not (pred)) into (_pred)
			  (if negated-pred (setq result (cons negated-pred (cdr result))))
			  (dolist (arg (cdr result))
			    (pushnew (cons (or (get-object-type arg)
					       (get-object-type (car (find arg anonymize-list :key #'cdr))))
					   arg)
				     *plan-constants* :key #'cdr))
			  (if precondsp
;;;; IMPORTANT: REMOVE PRECONDS THAT ARE ADDED BY SOME OTHER ACTION. GOAL-REGRESSION
			      (pushnew result *union-preconds* :test #'equal)
			      (pushnew result *union-effects* :test #'equal))
			  (if negated-pred (list 'not result) result))))))))))

(defun negated-pred (pred negated-preds)
  (car (member pred negated-preds :key #'(lambda (var) (intern (format nil "_~a" (symbol-name var)))))))

;; I add literals-in-plan to literals-defs since there could be new literals from processing the actions in the plan
(defun remove-irrelevant-defs (literals-defs literals-in-plan anonymize-list literals-others predicatesp)
  (let* ((noargs-literals (remove-if #'cdr literals-in-plan))
	 (defs (if predicatesp
		   (union noargs-literals literals-defs :test #'equal)
		   literals-defs)))
    (remove-if-not #'(lambda (literal-def)
		       (and (member (car literal-def) literals-in-plan :key #'car)
			    (or (rassoc literal-def anonymize-list :test #'equal)
				(rassoc (car literal-def) anonymize-list)
				(member (car literal-def) literals-others :key #'car))))
		   defs)))
    

(defun remove-previous-constants (constants previous-constants)
  (flatten-instances
   (mapcan #'(lambda (type-def)
	       (let ((difference (set-difference (cdr type-def) (cdr (assoc (car type-def) previous-constants)))))
		 (if difference
		     (list (cons (car type-def) difference)))))
	   (process-instances constants))))

(defun join-constants (constants constants-alist types)
  (let ((new-constants constants)
	(previous-def nil)
	(common-subtype nil))
    (dolist (constant-def constants-alist)
      (setq previous-def (find (cdr constant-def) new-constants :key #'cdr))
      (cond (previous-def
	     (setq common-subtype (find-common-subtype (car previous-def) (car constant-def) types))
	     (unless (eq (car previous-def) common-subtype)
	       (setq new-constants (remove previous-def new-constants :test #'equal))
	       (setq previous-def (remove (cdr constant-def) previous-def))
	       (push previous-def new-constants)
	       (if (assoc common-subtype new-constants)
		   (pushnew (cdr constant-def) (cdr (assoc common-subtype new-constants)))
		   (push (list common-subtype (cdr constant-def)) new-constants))))
	    ((assoc (car constant-def) new-constants)
	     (pushnew (cdr constant-def) (cdr (assoc (car constant-def) new-constants))))
	    (t (push (list (car constant-def) (cdr constant-def)) new-constants))))
    new-constants))

;; (defun compute-new-subgoals (previous-subgoals reachable-subgoals)
;;   (declare (special *subgoals-causal-graph*))
;;   (let ((weakest-preconds nil)
;; 	(new-subgoals previous-subgoals))
;;     (dolist (reachable-subgoal reachable-subgoals)
;;       (setq weakest-preconds (car (find-if #'(lambda (causal-relation)
;; 					       (member reachable-subgoal (cadr causal-relation) :test #'equal))
;; 					   *subgoals-causal-graph*)))
;;       (dolist (subgoal (intersection weakest-preconds previous-subgoals :test #'equal))
;; 	(setq new-subgoals (remove subgoal new-subgoals :test #'equal))))
;;     (append new-subgoals reachable-subgoals)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runs centralized standard (original -- e.g. lama-first, lpg-adapt, sayphi, ...)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun run-original-centralized (domain domain-file problem algorithm probsets-dir output-file timeout domain-dir
				 parallel-plan-p agent-types)
  (free-mem)
  (let ((init-time (get-internal-real-time))
	(parallelization-time 0)
	(centralized-solution nil)
	(makespan 0))
    (case algorithm
      ((lama-first lama-unit-cost lama-second lama-seq lama-opt cgamer lpg-adapt metric-ff cbp-estocastico))
      (ma-fd (setf *agents* (give-me-agents-from-problem (cdr (read-all-file (concatenate 'string probsets-dir problem)))
							 agent-types)))
      (otherwise
       (say-domain domain domain-file nil)
       (prob (concatenate 'string probsets-dir problem) nil)))
    (setq centralized-solution (the-ring algorithm timeout domain domain-file problem
					 :probsets-dir probsets-dir :domain-dir domain-dir))
    (cond ((and centralized-solution (solution-found centralized-solution) (> (solution-length centralized-solution) 0))
	   (setq parallelization-time (get-internal-real-time))
	   (setf *solution-centralized* (solution-path centralized-solution))
	   ;; MA-FD does not return a plan
	   (if (and *solution-centralized* parallel-plan-p (not (eq algorithm 'ma-fd)))
	       (setq makespan (+ 1 (caar (last (compute-parallel-plan domain domain-file problem probsets-dir
								      *solution-centralized* nil))))))
	   (if output-file
	       (with-open-file (ostream output-file :direction :output :if-exists :append :if-does-not-exist :create)
		 (format ostream "~%(~a ~a T 1 1 ~,2f ~d ~d ~,2f ~d)" algorithm (pathname-name problem)
			 (elapsed-time init-time 'real-time) (solution-num-nodes centralized-solution)
			 (solution-length centralized-solution) (elapsed-time parallelization-time 'real-time) makespan))
	       (format t "~%Summary ~a: Problem ~a, Solved: T, Time: ~,2f, Nodes: ~d, Length: ~d, Time to compute
				 parallel plan: ~,2f" algorithm problem
				 (elapsed-time init-time 'real-time) (solution-num-nodes centralized-solution)
				 (solution-length centralized-solution) (elapsed-time init-time 'real-time)))
	   (if (eq algorithm 'ma-fd) (sleep *ma-fd-sleeptime*)) ;; so that it stops all pending processes
	   centralized-solution)
	  (t (if output-file
		 (with-open-file (ostream output-file :direction :output :if-exists :append :if-does-not-exist :create)
		   (format ostream "~%(~a ~a nil 0 1 ~,2f 0 0)" algorithm (pathname-name problem)
			   (elapsed-time init-time 'real-time)))
		 (format t "~%Problem: ~a, Solved: NIL" problem))
	     (setf *solution-centralized* nil)
	     (if (eq algorithm 'ma-fd) (sleep 300)) ;; so that it stops all pending processes
	     nil))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;              Solution validation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; A simple solution validation tool (for now, just strips plans)
(defun validate-sol (&key (solution *say-solution*) (domain nil) (domain-file nil) (problem-file nil) (probsets-dir nil))
  (if (and domain domain-file)
      (say-domain domain domain-file nil))
  (if problem-file
      (prob (concatenate 'string probsets-dir problem-file) nil))
  (do* ((state (problem-lit-init-state *current-problem*))
	(plan (if (solution-p solution) (solution-path solution) solution) (cdr plan))
	(plan-step (car plan) (car plan))
	(negated-preds (dom-negative-preds *pspace*))
	(special-preds (dom-special-preds *pspace*))
	(all-goals-true-p nil)
	(invalid nil))
       ((or (null plan) invalid)
	(setq all-goals-true-p (every #'(lambda (goal) (member goal state :test #'equal))
				      (problem-lit-goals *current-problem*)))
	(if (not all-goals-true-p)
	    (format t "~2%Invalid plan: it doesn't achieve top level goals ~a"
		    (remove-if #'(lambda (goal) (member goal state :test #'equal))
			       (problem-lit-goals *current-problem*))))
	(and (not invalid) all-goals-true-p))
    (let* ((action (if (snode-p plan-step)
		       (snode-plan-action plan-step)
		       plan-step))
	   (action-name (car action))
	   (action-struct (find action-name (dom-actions *pspace*) :key #'action-name))
	   (parameters (action-parameters action-struct))
	   (substitution (mapcar #'cons parameters (cdr action))))
      (cond ((every #'(lambda (precond)
			(let ((negated-pred (negated-pred (car precond) negated-preds)))
			  (if negated-pred
			      (not (member (cons negated-pred (cdr precond)) state :test #'equal))
			      (if (eq (car precond) '=)
				  (eq (cadr precond) (caddr precond))
				  (if (negated-equality (car precond) special-preds)
				      (not (eq (cadr precond) (caddr precond)))
				      (member precond state :test #'equal))))))
		    (sublis substitution (action-preconditions action-struct)))
	     (setq state (union (set-difference state (sublis substitution (action-dels action-struct)) :test #'equal)
				(sublis substitution (action-adds action-struct)) :test #'equal)))
	    (t (format t "~2%Invalid action: ~a~%in state: ~a" action state)
	       (format t "~% precond unmet: ~a" (find-if-not #'(lambda (precond)
								 (if (negated-pred (car precond) negated-preds)
								     (not (member precond state :test #'equal))
								     (member precond state :test #'equal)))
							     (sublis substitution (action-preconditions action-struct))))
	       (setq invalid t))))))

(defun negated-equality (symbol special-preds)
  (let ((symbol-string (format nil "~a" (symbol-name symbol))))
    (and (eq (elt symbol-string 0) #\_)
	 (eq (elt symbol-string 1) #\=)
	 (member (intern (string-trim '(#\_ #\=) symbol-string)) special-preds))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;   Generation of results and scores (as IPC)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun generate-domains-results (&key (domains '("satellite" "rover" "driverlog" "depots" "zenotravel" "logistics"
						 "elevators" "transport" "port" "depots-robots"))
				   (prefix "*.lisp")
				   (style 'csv)
				   (dir "/result/")
				   (output-dir "/Users/dborrajo/Desktop/")
				   (output-file-name "results.csv"))
  (let ((command "")
	(results-dir "")
	(scores nil)
	(separator (case style
		     (csv "; ")
		     (tex " & ")
		     (plot " ")
		     (otherwise " ")))
	(output-file (concatenate 'string output-dir output-file-name)))
    (with-open-file (ostream output-file :direction :output :if-exists :supersede :if-does-not-exist :create))
    (dolist (domain domains)
      (with-open-file (ostream output-file :direction :output :if-exists :append :if-does-not-exist :create)
	(format ostream "~2%~a~%" domain))
      (setq results-dir (format nil "~a~(~a~)~a" *domains-dir* domain dir))
      (push (cons domain (generate-csv-results domain :results-prefix-list prefix
					       :results-dir results-dir
					       :output-file "results.csv"
					       :style style :separator separator))
	    scores)
      (setq command (format nil "cd ~a; cat ~aresults.csv >> ~a" output-dir results-dir output-file-name))
      (execute-shell-command command))
    (setq scores (nreverse scores))
    ;; prints summary
    (with-open-file (ostream output-file :direction :output :if-exists :append :if-does-not-exist :create)
      (format ostream "~2%Domains~a" separator)
      (dolist (score (cdar scores))
	(format ostream "C~a~aT~a~aL~a~aM~a~a" (car score) separator (car score) separator (car score) separator (car score) separator))
      (dolist (dom-score scores)
	(format ostream "~%~a~a" (car dom-score) separator)
	(dolist (score (cdr dom-score))
	  (format ostream "~a~a~a~a~a~a~a~a" (nth 1 score) separator (print-coma (nth 2 score)) separator
		  (print-coma (nth 3 score)) separator (print-coma (nth 4 score)) separator))))))

;; style can be: csv, tex or plot
;; I separate with semicolon in csv, given that I am using spanish excel. If you use english excel, change for comma and
;; change all calls to print-coma for the corresponding format (~,3f)
;; (generate-csv-results "rover")
(defun generate-csv-results (domain &key (results-prefix-list (list "pfile*"))
				      (style 'csv)
				      (results-dir (format nil "~a~(~a~)/result/" *domains-dir* domain))
				      (only-scores-p nil)
				      (output-file (format nil "results.~a" style))
				      (separator "; "))
  (let* ((all-results (mapcar #'(lambda (result-file)
				  (cons (generate-configuration-name result-file)
					(generate-results-list result-file)))
			      (mapcan #'(lambda (result-prefix)
					  (directory (concatenate 'string results-dir result-prefix)))
				      (if (listp results-prefix-list) results-prefix-list (list results-prefix-list)))))
	 (num-probs (length (cdar all-results)))
	 (first-result-p nil)
	 (scores nil))
    (with-open-file (ostream (concatenate 'string results-dir output-file)
			     :direction :output :if-exists :supersede :if-does-not-exist :create)
      (apply #'(lambda (&rest list)
		 (setq first-result-p t)
		 (dolist (rlist list)
		   (if only-scores-p
		       (if first-result-p (format ostream "Problem"))
		       (if first-result-p
			   (format ostream "Problem~a~a~aT~aL~aM" separator (car rlist) separator separator separator)
			   (format ostream "~a~a~aT~aL~aM" separator (car rlist) separator separator separator)))
		   (setq first-result-p nil))
		 (if (not only-scores-p)
		     (format ostream "~aBT~aBL~aBM" separator separator separator))
		 (dolist (rlist list)
		   (format ostream "~aTS~a~aLS~a~aMS~a"
			   separator (car rlist) separator (car rlist) separator (car rlist)))
		 (setq scores (print-scores list num-probs separator ostream))
		 ;; printing totals
		 (format ostream "~%Total~a" separator)
		 (dolist (score scores)
		   (format ostream "~d~a~a~a~a" (nth 0 score) separator separator separator separator))
		 (format ostream "~a~a~a" separator separator separator)
		 (dolist (score scores)
		   (format ostream "~a~a~a~a~a~a" (print-coma (nth 1 score)) separator
			   (print-coma (nth 2 score)) separator (print-coma (nth 3 score)) separator))
		 (setq scores (mapcar #'(lambda (rlist score)
					  (cons (car rlist) score))
				      list scores)))
	     all-results))
    scores))

(defun generate-configuration-name (filename)
  (pathname-name filename))

;; takes a result file as input and returns a list of sublists (prob-name solved time cost makespan)
;; solved is 0 or 1
(defun generate-results-list (file)
  (mapcar #'(lambda (result)
	      (list (nth 1 result) (if (nth 2 result) 1 0)
		    (if (and (nth 2 result) (<= (nth 5 result) 1.0))
			1.0
			(nth 5 result))
		    (nth 7 result) (nth 12 result)))
	  (read-all-file file)))

;; prints the individual scores per problem and configuration
(defun print-scores (list num-probs separator ostream)
  (let ((min-time most-positive-fixnum)
	(min-length most-positive-fixnum)
	(min-makespan most-positive-fixnum)
	time-score length-score makespan-score
	(first-result-p t)
	;; coverage time length makespan
	(scores (make-list (length list) :initial-element nil)))
    (dotimes (i (length list))
      (setf (nth i scores) (make-list 4 :initial-element 0)))
    (dotimes (i num-probs)
      (do* ((j 0 (1+ j))
	    (the-list list (cdr the-list))
	    (rlist (car the-list) (car the-list)))
	   ((null the-list))
	(unless (zerop (nth 1 (nth (1+ i) rlist)))
	  (setq min-time (min (nth 2 (nth (1+ i) rlist)) min-time))
	  (setq min-length (min (nth 3 (nth (1+ i) rlist)) min-length))
	  (setq min-makespan (min (or (nth 4 (nth (1+ i) rlist)) (nth 3 (nth (1+ i) rlist))) min-makespan)))
	;; 	(format t "~%list: ~a, time: ~a, min-time: ~a" (nth (1+ i) rlist) (nth 2 (nth (1+ i) rlist)) min-time)
	(if first-result-p (format ostream "~%~a" (nth 0 (nth (1+ i) rlist))))
	(setq first-result-p nil)
	(format ostream "~a~d~a~a~a~a~a~a" separator (nth 1 (nth (1+ i) rlist)) separator
		(print-coma (nth 2 (nth (1+ i) rlist))) separator
		(nth 3 (nth (1+ i) rlist)) separator (or (nth 4 (nth (1+ i) rlist)) (nth 3 (nth (1+ i) rlist))))
	(incf (nth 0 (nth j scores)) (nth 1 (nth (1+ i) rlist))))
;; 	(print scores))
      (format ostream "~a~a~a~d~a~d" separator (print-coma min-time) separator min-length separator min-makespan)
;;       (format t "BT: ~a, BL: ~d, BM: ~d" (print-coma min-time) min-length min-makespan)
      (do* ((j 0 (1+ j))
	    (the-list list (cdr the-list))
	    (rlist (car the-list) (car the-list)))
	   ((null the-list))
	(cond ((zerop (nth 1 (nth (1+ i) rlist)))
	       (format ostream "~a0,0~a0,0~a0,0" separator separator separator))
	      (t (format ostream "~a~a~a~a~a~a" separator
			 (print-coma (setq time-score (/ 1.0 (1+ (log (/ (nth 2 (nth (1+ i) rlist)) min-time) 10)))))
			 separator
			 (print-coma (setq length-score (/ min-length (nth 3 (nth (1+ i) rlist)) 1.0)))
			 separator
			 (print-coma (setq makespan-score (/ min-makespan (or (nth 4 (nth (1+ i) rlist)) (nth 3 (nth (1+ i) rlist))) 1.0))))
		 (incf (nth 1 (nth j scores)) time-score)
		 (incf (nth 2 (nth j scores)) length-score)
		 (incf (nth 3 (nth j scores)) makespan-score))))
      (setq first-result-p t)
      (setq min-time most-positive-fixnum)
      (setq min-length most-positive-fixnum)
      (setq min-makespan most-positive-fixnum))
    scores))

(defun print-coma (n)
  (substitute #\, #\. (format nil "~,2f" n)))

;; Given a directory with the domain info, it returns a pathname to the relative parent dir
(defun build-domains-dir (domain-dir)
  (let ((dirs (pathname-directory (concatenate 'string domain-dir "/"))))
    (concatenate 'string (if (eq (car dirs) :absolute) "/" "")
		 (reduce #'(lambda (str1 str2)
			     (concatenate 'string
					  (if (eq str1 :up)
					      ".."
					      str1)
					  "/"
					  (if (eq str2 :up)
					      ".."
					      str2)))
			 (butlast (cdr dirs)))
		 "/")))

			   
(defun generate-plot-ma (file ofile)
  (let ((all-results (read-all-file file))
	(num-solved-centralized 0)
	(num-solved-distributed 0))
    (with-open-file (ostream ofile :direction :output :if-exists :supersede :if-does-not-exist :create)
      (do* ((results all-results (cddr results)))
	   ((null results))
	(cond ((nth 2 (caar results))
	       (incf num-solved-centralized)
	       (format ostream "~%~,2f ~d ~d" (nth 5 (caar results)) (nth 6 (caar results)) (nth 7 (caar results))))
	      (t (format ostream "~%0.0 0 0")))
	(cond ((nth 2 (cadar results))
	       (incf num-solved-distributed)
	       (format ostream " ~,2f ~d ~d" (nth 5 (caadr results)) (nth 6 (caadr results)) (nth 7 (caadr results))))
	      (t (format ostream " 0.0 0 0")))))
    (format t "~2%#solved centralized: ~d, #solved mapr: ~d" num-solved-centralized num-solved-distributed)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;               Auxiliary functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun trace-ma-sayphi nil
  (setf *trace-ma-sayphi* t)
  (trace call-agent))

(defun untrace-ma-sayphi nil
  (setf *trace-ma-sayphi* nil)
  (untrace))

(defun pp-agent (agent stream z)
  (declare (type agent agent)
	   (stream stream)
	   (ignore z))
  (format stream "#<~a>" (agent-name agent)))

;; properties is a list of agents attributes that we want to print. It will not print the rest of attributes
(defun pp-agents (&key (ofile nil) (properties :all))
  (cond (ofile
	 (with-open-file (ostream ofile :direction :output :if-exists :supersede :if-does-not-exist :create)
	   (format ostream "(")
	   (dolist (agent *agents*)
	     (format ostream "~% (~a ~a" (agent-name agent) (agent-type agent))
	     (if (or (eq properties :all) (member 'assigned-goals properties))
		 (format ostream "~%   ~a" (agent-assigned-goals agent)))
	     (if (or (eq properties :all) (member 'votes properties))
		 (format ostream "~%   ~a" (agent-votes agent)))
	     (if (or (eq properties :all) (member 'anonymize-list properties))
		 (format ostream "~%   ~a" (agent-anonymize-list agent)))
	     (if (or (eq properties :all) (member 'reverse-anonymize-list properties))
		 (format ostream "~%   ~a" (agent-reverse-anonymize-list agent)))
	     (if (or (eq properties :all) (member 'positions-in-actions properties))
		 (format ostream "~%   ~a" (agent-positions-in-actions agent)))
	     (if (or (eq properties :all) (member 'problem-file properties) (member 'domain-file properties))
		 (format ostream "~%   ~s ~s" (agent-domain-file agent) (agent-problem-file agent)))
	     (if (or (eq properties :all) (member 'mapr-problem-file properties) (member 'mapr-domain-file properties))
		 (format ostream "~%   ~s ~s" (agent-mapr-domain-file agent) (agent-mapr-problem-file agent)))
	     (if (or (eq properties :all) (member 'predicates properties))
		 (format ostream "~%   ~a" (agent-predicates agent)))
	     (if (or (eq properties :all) (member 'static-predicates properties))
		 (format ostream "~%   ~a" (agent-static-predicates agent)))
	     (if (or (eq properties :all) (member 'macro-operators properties))
		 (format ostream "~%   ~a)" (agent-macro-operators agent)))
	     (if (or (eq properties :all) (member 'subgoals properties))
		 (format ostream "~%   ~a" (agent-subgoals agent)))
	     (if (or (eq properties :all) (member 'private-goals properties))
		 (format ostream "~%   ~a" (agent-private-goals agent))))
	   (format ostream ")")))
	(t (dolist (agent *agents*)
	     (format t "~2%~a ~a" (agent-type agent) (agent-name agent))
	     (if (or (eq properties :all) (member 'votes properties))
		 (format t "~% Votes: ~a" (agent-votes agent)))
	     (if (or (eq properties :all) (member 'assigned-goals properties))
		 (format t "~% Assigned-goals: ~a" (agent-assigned-goals agent)))
	     (if (or (eq properties :all) (member 'anonymize-list properties))
		 (format t "~% Anonymize list: ~a" (agent-anonymize-list agent)))
	     (if (or (eq properties :all) (member 'reverse-anonymize-list properties))
		 (format t "~% Reverse anonymize list: ~a" (agent-reverse-anonymize-list agent)))
	     (if (or (eq properties :all) (member 'positions-in-actions properties))
		 (format t "~% Positions in actions: ~a" (agent-positions-in-actions agent)))
	     (if (or (eq properties :all) (member 'problem-file properties))
		 (format t "~% Problem-file: ~a" (agent-problem-file agent)))
	     (if (or (eq properties :all) (member 'domain-file properties))
		 (format t "~% Domain file: ~a" (agent-domain-file agent)))
	     (if (or (eq properties :all) (member 'predicates properties))
		 (format t "~% Predicates: ~a" (agent-predicates agent)))
	     (if (or (eq properties :all) (member 'static-predicates properties))
		 (format t "~% Static predicates: ~a" (agent-static-predicates agent)))
	     (if (or (eq properties :all) (member 'macro-operators properties))
		 (format t "~% Macro-operators: ~a" (agent-macro-operators agent)))
	     (if (or (eq properties :all) (member 'subgoals properties))
		 (format t "~% Subgoals: ~a" (agent-subgoals agent)))
	     (if (or (eq properties :all) (member 'private-goals properties))
		 (format t "~%   ~a" (agent-private-goals agent)))))))

(defun report-undefined-predicates (new-predicates predicates-in-problem)
  (let ((predicates-in-problem-undefined-in-domain (remove-if #'(lambda (predicate)
								  (member predicate new-predicates :key #'car))
							      predicates-in-problem)))
    (when predicates-in-problem-undefined-in-domain
      (format t "~%The following predicates are defined in the problem, but not in the domain:")
      (dolist (predicate predicates-in-problem-undefined-in-domain)
	(format t " ~a" predicate))
      (terpri))))

(defun ediff-problems (problem1 problem2 &key (probsets-dir (concatenate 'string *domain-dir* "probsets/")))
  (let ((problem-def1 (cdr (read-all-file (concatenate 'string probsets-dir problem1))))
	(problem-def2 (cdr (read-all-file (concatenate 'string probsets-dir problem2)))))
    (format t "~%State in ~a and not in ~a:~% ~a" problem1 problem2
	    (set-difference (find-argument problem-def1 :init) (find-argument problem-def2 :init) :test #'equal))
    (format t "~%State in ~a and not in ~a:~% ~a" problem2 problem1
	    (set-difference (find-argument problem-def2 :init) (find-argument problem-def1 :init) :test #'equal))
    (format t "~%Goals in ~a and not in ~a:~% ~a" problem1 problem2
	    (set-difference (give-me-all-goals problem-def1) (give-me-all-goals problem-def2) :test #'equal))
    (format t "~%Goals in ~a and not in ~a:~% ~a" problem2 problem1
	    (set-difference (give-me-all-goals problem-def2) (give-me-all-goals problem-def1) :test #'equal))))

(defun write-message (message force-write-p &rest args)
  (when (or *trace-ma-sayphi* force-write-p)
    (format t "~2%************************************************************************************************************")
    (apply #'format `(t ,(format nil "~%**  ~a" message) ,@args))
    (format t "~%************************************************************************************************************")))
