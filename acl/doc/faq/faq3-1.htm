<html>

<head>
<title>Allegro CL FAQ 3.1: Questions about the base Lisp</title>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
</head>

<body>

<h3>3.1: Questions about the Base Lisp</h3>

<blockquote>
  <p><a href="#311">Q 3.1-1) I'm left with running Lisp processes after I exit my
  Emacs/xterm. What do I do to avoid this?</a><br>
  <a href="#312">Q 3.1-2) Why doesn't make-pathname merge the given :directory component
  with the directory component in :defaults argument?</a><br>
  <a href="#313">Q 3.1-3) I am getting stack overflows and occasional Lisp failure when I
  sort on large arrays. Why and what can I do?</a><br>
  <a href="#314">Q 3.1-4) I have set the stack cushion to a reasonable value, but the soft
  stack limit is not being detected, and I get a lisp death instead. Why is that?</a><br>
  <a href="#315">Q 3.1-5) Why does it take so long to load a file that interns several
  thousand symbols in a package?</a></p>
</blockquote>

<p><a href="index.htm">Go to main FAQ page.</a></p>

<hr>

<p><a name="311"></a><strong>Q 3.1-1)</strong> I'm left with running Lisp processes after
I exit my Emacs/xterm. What do I do to avoid this?</p>

<p><strong>A 3.1-1)</strong> This issue is very complicated: whether and how lisp should
terminate when its input/output streams are broken. The current implementation <em>should</em>
give the behavior most people want, that a lisp image quietly and immediately ceases
execution when its remote initial terminal io stream is closed.</p>

<p>If it doesn't, here is some code you can load into an image or otherwise cause to
execute (e.g. in ~.clinit.cl) that might have useful effect in making lisp images go away
when you want them to.</p>

<pre>#-(version&gt;= 4 3)
(progn
&nbsp; (unless (fboundp 'unix-signal)
&nbsp;&nbsp;&nbsp; (ff:defforeign 'unix-signal :entry-point (ff:convert-to-lang &quot;signal&quot;)))</pre>

<pre>&nbsp; (unix-signal 1 0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;SIGINT
&nbsp; (unix-signal 15 0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;SIGTERM
   )</pre>

<hr>

<p><a name="312"></a><strong>Q 3.1-2)</strong> Why doesn't make-pathname merge the given
:directory component with the directory component in :defaults argument?</p>

<p><strong>A 3.1-2)</strong> Section 19.4.4 of the ANSI spec says:</p>

<blockquote>
  <p>After the components supplied explicitly by host, device, directory, name, type, and
  version are filled in, the merging rules used by merge-pathnames are used to fill in any
  unsupplied components from the defaults supplied by defaults. </p>
</blockquote>

<p><em>unsupplied</em> is the crucial word here. By specifying a <font face="Courier New">:directory</font>
argument you have supplied the directory component, and the directory component of the <font
face="Courier New">:defaults</font> argument is not used. Even specifying <font
face="Courier New">:directory nil</font> explicitly supplies a directory component of <font
face="Courier New">nil</font>, and this will be treated differently from <em>unsupplied</em>.</p>

<hr>

<p><a name="313"></a><strong>Q 3.1-3)</strong> I am getting stack overflows and occasional
Lisp failure when I sort on large arrays. Why and what can I do?</p>

<p>Here is a transcript showing a stack overflow. Note that the array has one million
(10^6) elements.</p>

<pre>USER(1): (setq pippo (make-array 1000000 :initial-element 0)) 
#(0 0 0 0 0 0 0 0 0 0 ...)
USER(2): (sort pippo #'&lt;)
Error: Stack overflow (signal 1000)
[condition type: SYNCHRONOUS-OPERATING-SYSTEM-SIGNAL]

Restart actions (select using :continue):
 0: continue computation
 1: Return to Top Level (an &quot;abort&quot; restart)
[1c] USER(3): :pop
=================^^^^
USER(4): (sort pippo #'&lt;)
#(0 0 0 0 0 0 0 0 0 0 ...)
USER(5): </pre>

<p>Here I continue the computation and Lisp exits with a segmentation violation:</p>

<pre>USER(1): (setq pippo (make-array 1000000 :initial-element 0))
#(0 0 0 0 0 0 0 0 0 0 ...)
USER(2): (sort pippo #'&lt;)
Error: Stack overflow (signal 1000)
 [condition type: SYNCHRONOUS-OPERATING-SYSTEM-SIGNAL]

 Restart actions (select using :continue):
 0: continue computation
 1: Return to Top Level (an &quot;abort&quot; restart)
[1c] USER(3): (sort pippo #'&lt;)
Segmentation fault (core dumped)
%
</pre>

<p><strong>A 3.1-3)</strong> The stack overflow occurs because a large array is being
stack-allocated to perform the sort. The size of the array is architecture dependent;
Windows platforms only allocate up to 4 Kbyte arrays on the stack, and normally heap
allocate any larger arrays needed, while Unix platforms attempt to allocate 4 Mbyte arrays
on the stack. On any architecture, the strategy is programmable; as described below.</p>

<p>When the above error occurs, there are several things that can be done. 

<ol>
  <li>Instead of popping out of the break loop as in the example above, just continue. The
    stack overflow automatically reduces the stack cushion (see documentation for <a
    href="../operators/system/stack-cushion.htm">sys:stack-cushion</a> and <a
    href="../operators/system/set-stack-cushion.htm">sys:set-stack-cushion</a>), so
    continuing should allow further execution.</li>
  <li>On Unix platforms only, a <strong>csh</strong> can be run and the limit command used to
    set the stack limit to something larger than it currently is. We recommend at least 8192
    Kbytes (8 megabytes), but if that is not enough, more can be allocated. </li>
  <li>Change the sort strategy (documented below). The Allegro CL implementation of the <strong>sort</strong>
    function tries to allocate a temporary array on the stack if possible, so that it does not
    need to do so on the heap. If this strategy is not acceptable or convenient, change the
    strategy to either allocate from the heap or to use a pre-existing user supplied array. </li>
</ol>

<p>Just continuing usually works as does, usually, clearing stack with a :reset and
retrying. Note, as the second example above shows, trying to redo the sort command in the
error prompt (that is, without clearing the error) can result in an abnormal exit from the
lisp (Segmentation fault (core dumped) ).</p>

<p>This is an unfortunate hole in our stack-overflow detection strategy; Stack overflow is
normally detected for every function call, and enough &quot;slop&quot; is allowed for so
that functions that allocate an average amount of stack will not cause a hard stack
overflow. But if the function allocates large stack objects (such as large temporary
vectors) then the jump in stack usage is too much to detect by either the stack cushion or
the hardware overflow detection, and stack-overflow death occurs. We hope to guard against
such overflow death in some future version of Allegro CL.</p>

<p><strong>Sort Strategy:&nbsp; </strong></p>

<p>You can tell the system whether to try to stack-allocate things to be sorted. From the
documentation in the source code:</p>

<pre>;; excl::*simple-vector-sort-strategy*:
;;
;; The sort strategy can be one of three types:
;; :stack - try to allocate stack space for the temp sort; this
;; works easily for 1k elements (4 kbytes), and (on
;; Unix platforms only) for up to 1m elements (4 mbytes)
;; if there is enough stack allocated by the os; more
;; than 1 m elements cause a new svector to be allocated.
;; :alloc - Allocate an svector of size equal to the vector to sort.
;; a new one is allocated each time.
;; &lt;vector&gt; - must be a simple-vector of type t of at least as many
;; elements as are being sorted. During the sort, the global
;; is reset to :alloc so that sort is re-entrant.

(defvar excl::*simple-vector-sort-strategy* :stack)</pre>

<hr>

<p><a name="314"></a><strong>Q 3.1-4)</strong> I have set the stack cushion (see <a
href="../operators/system/set-stack-cushion.htm">sys:set-stack-cushion</a> and <a
href="../operators/system/stack-cushion.htm">sys:stack-cushion</a>) to a reasonable
value, but the soft stack limit is not being detected, and I get a lisp death instead. Why
is that? </p>

<p><strong>A 3.1-4)</strong> The stack-cushion is detected in &quot;symbol
trampoline&quot;, a short piece of code that is used when one Lisp function calls another.
It is meant to flag normal situations where stack is growing too quickly, and to signal a
condition before a hard stack-size limit is reached. </p>

<p>There are several possible situations where the stack-overflow is not detected by this
mechanism, and careful thought must be given as to how to handle it: 

<ol>
  <li>A lisp function may allocate a very large stack size, due to either a large number of
    variables or due to large stack-allocated arrays or lists. If the amount that the function
    allocates is larger than the difference between the hard stack limit and the soft stack
    limit set up by the stack cushion, then there will be no chance for the Lisp to signal the
    condition before the hard limit is reached. The only way to work around this problem is to
    be sure that there is sufficient stack-cushion for the worst-case function to allocate its
    needed stack. </li>
  <li>A Lisp function might call itself recursively, which on some architectures generates a
    fast call to location 0 of the same function. The fast call causes the symbol trampoline
    to be bypassed, thus causing the stack overflow detection to also be bypassed. The
    workaround is to declare the function calling itself as notinline within its own body.
    This will result in slightly slower code generation, but overflows would then be detected.
    Example: </li>
</ol>

<blockquote>
  <p>(defun call-me ( ... ) <br>
  &nbsp; (declare (notinline call-me)) <br>
  &nbsp; ... <br>
  &nbsp; (call-me ...) ... ) </p>
</blockquote>

<ol start="3">
  <li>A non-lisp thread may be called, at which time there is no way to limit the stack on
    some machines. There is no workaround for this problem, other than to reduce ones
    dependence on non-lisp code.</li>
</ol>

<hr>

<p><a name="315"></a><strong>Q 3.1-5)</strong> Why does it take so long to load a file
that interns several thousand symbols in a package?</p>

<p><strong>A 3.1-5)</strong> A package has an associated hashtable for the names of
symbols in the package. When the size of a package is not specified at creation time, a
default hashtable is used. Its initial size is small, allowing for 10 entries, and it
tends to grow slowly, growing about 20% each time growth is necessary. Those values are
reasonable for most uses, but if you know that a package will have many more symbols,
particularly if they will be all created at roughly the same time (as when reading a file
that interns thousands of symbols), you should specify the :size keyword argument to <strong>defpackage</strong>
appropriately when creating the package. Thus, if you know the package will eventually
have about 4000 symbols, define it with a form like this:</p>

<pre>(defpackage :foo (:size 4000) (:use :cl :excl))</pre>

<hr>

<p><strong>Next FAQ topic</strong>: <a href="faq3-2.htm">3.2. Garbage collector</a></p>

<p><strong>Previous FAQ topic</strong>: <a href="faq2-8.htm">Architecture specific
problems: 2.8. MacOS X</a></p>

<hr>

<p><small>© Copyright 1999-2004, Franz Inc., Berkeley, CA.&nbsp; All rights reserved.</small><br>
<small>$Revision: 1.1.1.1 $</small></p>
</body>
</html>
